From fd019c533e7e993fccb4e987b20ea7bed8cfeddc Mon Sep 17 00:00:00 2001
From: Damien Horsley <Damien.Horsley@imgtec.com>
Date: Mon, 2 Feb 2015 02:22:43 +0000
Subject: [PATCH 24/40] ASoC: img: Add IMG audio and event timer drivers

This commit addds following:

1. Event timer driver

2. ALSA startat
- Implement START_AT ioctl
- Implement start_at for system (posix) clocks using hi-res timers
- Implement start_at for audio clocks by forwarding to new fields in
	* snd_pcm_ops
	* snd_soc_ops
	* snd_soc_dai_ops
	* snd_soc_platform_driver

3. add pistachio audio card drivers

Signed-off-by: Damien.Horsley <Damien.Horsley@imgtec.com>
Signed-off-by: Tim Cussins <tim.cussins@linn.co.uk>
Signed-off-by: Ian Pozella <Ian.Pozella@imgtec.com>
---
 .../bindings/sound/img,pistachio-audio.txt         |  252 ++
 .../bindings/sound/img,pistachio-event-timer.txt   |   63 +
 include/dt-bindings/sound/pistachio-audio.h        |    8 +
 include/sound/dmaengine_pcm.h                      |    6 +
 include/sound/pcm.h                                |   24 +
 include/sound/soc-dai.h                            |    5 +
 include/sound/soc.h                                |    3 +
 include/uapi/sound/asound.h                        |   15 +
 kernel/time/clocksource.c                          |    1 +
 sound/core/pcm.c                                   |    4 +-
 sound/core/pcm_compat.c                            |   22 +
 sound/core/pcm_dmaengine.c                         |    3 +-
 sound/core/pcm_lib.c                               |    2 +
 sound/soc/img/Kconfig                              |   44 +
 sound/soc/img/Makefile                             |    5 +
 sound/soc/img/pistachio-event-timer-atu.c          |   68 +
 sound/soc/img/pistachio-event-timer-internal.h     |   70 +
 sound/soc/img/pistachio-event-timer-local.c        |  186 ++
 sound/soc/img/pistachio-event-timer.c              |  995 ++++++++
 sound/soc/img/pistachio-event-timer.h              |   82 +
 sound/soc/img/pistachio.c                          | 2396 ++++++++++++++++++++
 sound/soc/soc-generic-dmaengine-pcm.c              |   79 +-
 sound/soc/soc-pcm.c                                |   89 +
 23 files changed, 4419 insertions(+), 3 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/img,pistachio-audio.txt
 create mode 100644 Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
 create mode 100644 include/dt-bindings/sound/pistachio-audio.h
 create mode 100644 sound/soc/img/pistachio-event-timer-atu.c
 create mode 100644 sound/soc/img/pistachio-event-timer-internal.h
 create mode 100644 sound/soc/img/pistachio-event-timer-local.c
 create mode 100644 sound/soc/img/pistachio-event-timer.c
 create mode 100644 sound/soc/img/pistachio-event-timer.h
 create mode 100644 sound/soc/img/pistachio.c

diff --git a/Documentation/devicetree/bindings/sound/img,pistachio-audio.txt b/Documentation/devicetree/bindings/sound/img,pistachio-audio.txt
new file mode 100644
index 0000000..9024641
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-audio.txt
@@ -0,0 +1,252 @@
+Imagination Technologies Pistachio Audio Card Driver
+
+Required properties:
+
+  - compatible : Compatible list, must contain "img,pistachio-audio"
+
+  - clocks : Contains an entry for each entry in clock-names
+
+  - clock-names : Includes the following entries:
+        "audio_pll"  The audio PLL
+        "i2s_mclk"   The i2s reference clock
+                     Also connected to i2s_out_0_mclk output
+        "dac_clk"    Dac reference clock. Connected to i2s_dac_clk output
+
+  - img,cr-periph : phandle of the peripheral control syscon
+                    node which contains the i2s loopback control registers
+
+  - img,event-timer : phandle of event timer
+
+Optional properties:
+
+  - img,widgets : Please refer to widgets.txt
+
+  - img,routing : A list of the connections between audio components.
+              Each entry is a pair of strings, the first being the
+              connection's sink, the second being the connection's
+              source
+
+  - img,mute-gpio : phandle of the mute gpio
+
+  - img,hp-det-gpio : phandle of headphone detect gpio
+
+  - img,i2s-clk-loopback : LRCLK+BCLK signals for i2s out and i2s in
+			   controllers are connected internally
+
+Optional subnodes:
+
+  - spdif-out : Contains spdif out information
+
+  - spdif-in : Contains spdif in information
+
+  - parallel-out : Contains parallel out information
+
+  - i2s-out : Contains i2s out information
+
+  - i2s-in : Contains i2s in information
+
+Required spdif-out subnode properties:
+
+  - cpu-dai : phandle of spdif out cpu dai
+
+Required spdif-in subnode properties:
+
+  - cpu-dai : phandle of spdif in cpu dai
+
+Required parallel-out subnode properties:
+
+  - cpu-dai : phandle of parallel out cpu dai
+
+  - sound-dai : phandle of internal dac
+
+Required i2s-out subnode properties:
+
+  - cpu-dai : phandle of i2s out cpu dai
+
+  - format : I2S out format. "i2s" and "left_j" are supported by
+		     the Pistachio iteration of the i2s out controller
+
+Optional i2s-out subnode properties:
+
+  - bitclock-inversion : i2s out BCLK inversion
+
+  - frame-inversion : i2s out LRCLK inversion
+
+  - continuous-clock : i2s out BCLK and LRCLK always active
+
+Optional i2s-out subnodes:
+
+  - <codec-name> : Contains codec information. <codec-name> will be used as
+		   the prefix for the codec. This name must be unique for
+		   each individual codec (unique codec device node), and
+		   cannot be equal to "internal-dac". The name
+		   should be short to avoid control name truncation
+
+Required i2s-in subnode properties:
+
+  - cpu-dai : phandle of i2s in cpu dai
+
+  - format : i2s in format. "i2s" and "left_j" are supported by
+	     the Pistachio iteration of the i2s in controller
+
+Optional i2s-in subnode properties:
+
+  - bitclock-inversion : i2s out BCLK inversion
+
+  - frame-inversion : i2s out LRCLK inversion
+
+  - continuous-clock : i2s out BCLK and LRCLK always active
+
+Optional i2s-in subnodes:
+
+  - <codec-name> : Contains codec information. <codec-name> will be used as
+		   the prefix for the codec. This name must be unique for
+		   each individual codec (unique codec device node), and
+		   cannot be equal to "internal-dac". The name
+		   should be short to avoid control name truncation
+
+Required <codec-name> subnode properties:
+
+  - mclk : Contains the mclk (master clock) used by the DAC/ADC.
+	   Valid identifiers (dt-bindings/sound/pistachio-audio.h):
+
+	       PISTACHIO_MCLK_NONE      No mclk is required, or mclk is
+					provided externally with no software
+					intervention required to compenstate
+					for differing sample rates
+
+	       PISTACHIO_MCLK_I2S       mclk is provided by the i2s_out_0_mclk
+					output from pistachio SoC. This clock
+					is shared with the internal i2s out
+					controller
+
+	       PISTACHIO_MCLK_DAC_CLK   mclk is provided by the i2s_dac_clk
+					output from pistachio SoC
+
+Required <codec-name> subnode properties if mclk is not PISTACHIO_MCLK_NONE:
+
+  - mclk-fs : Contains the set of fs ratios the DAC/ADC accepts (Nfs for
+	      sample rate r specifies the master clock input to the DAC is
+	      N times r). It is assumed this set of ratios is applicable to
+	      any given sample rate where this does not lead to a violation
+	      of the minimum/maximum frequencies specified by mclk-min-freq
+	      and mclk-max-freq respectively
+
+  - mclk-min-freq : Contains the minimum frequency the DAC/ADC accepts for
+		    its master clock input
+
+  - mclk-max-freq : Contains the maximum frequency the DAC/ADC accepts for
+		    its master clock input
+
+Optional <codec-name> subnode properties:
+
+  - sound-dai : phandle of the codec. If the codec does not accept/require
+		software configuration, this can be omitted
+
+  - mclk-index : Index of the mclk, used for snd_soc_dai_set_sysclk call.
+		 0 is used if this property is omitted
+
+  - frame-master : Indicates this codec is the LRCLK master
+
+  - bitclock-master : Indicates this codec is the BCLK master
+
+  frame-master and bitclock-master cannot exist in more than one of the codec
+  subnodes
+
+  frame-master and bitclock-master cannot be used within i2s out codec subnodes
+  as the Pistachio iteration of the i2s out controller accepts master mode
+  only
+
+  frame-master and bitclock-master can be omitted if img,i2s-clk-loopback is
+  used, or if LRCLK/BCLK generation does not require software intervention (eg
+  a codec operating in hardware-mode)
+
+Example 1 (Pistachio Bring-Up Board With Codec Daughterboard Inserted):
+
+All audio components present on board. 2x pcm3168a codecs provide 3 i2s in
+and out channels each. dac_clk provides the single master clock to both
+codecs. The Pistachio i2s out controller is the LRCLK+BCLK master for the DAC
+path. The second pcm3168a codec is the LRCLK+BCLK master for the ADC path
+
+pistachio_audio_card {
+	compatible = "img,pistachio-audio";
+
+	clocks = <&clk_core CLK_AUDIO_PLL>,
+		 <&clk_core CLK_I2S_DIV>,
+		 <&clk_core CLK_AUDIO>;
+	clock-names = "audio_pll", "i2s_mclk", "dac_clk";
+
+	img,cr-periph = <&cr_periph>;
+	img,event-timer = <&event_timer>;
+
+	img,mute-gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
+	img,hp-det-gpio = <&gpio5 3 GPIO_ACTIVE_LOW>;
+
+	img,widgets = "Headphone", "Headphones",
+		      "Speaker", "Speakers",
+		      "Line", "RCA Out";
+
+	img,routing = "Headphones", "internal-dac AOUTL",
+		      "Headphones", "internal-dac AOUTR",
+		      "Speakers", "internal-dac AOUTL",
+		      "Speakers", "internal-dac AOUTR",
+		      "RCA Out", "internal-dac AOUTL",
+		      "RCA Out", "internal-dac AOUTR";
+
+	spdif-out {
+		cpu-dai = <&spdif_out>;
+	};
+
+	spdif-in {
+		cpu-dai = <&spdif_in>;
+	};
+
+	parallel-out {
+		cpu-dai = <&parallel_out>;
+		sound-dai = <&internal_dac>;
+	};
+
+	i2s-out {
+		cpu-dai = <&i2s_out>;
+		format = "i2s";
+
+		pcm3168a-1 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <128 192 256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_1 0>;
+		};
+
+		pcm3168a-2 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <128 192 256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_2 0>;
+		};
+	};
+
+	i2s-in {
+		cpu-dai = <&i2s_in>;
+		format = "i2s";
+
+		pcm3168a-1 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_1 1>;
+		};
+
+		pcm3168a-2 {
+			mclk = <PISTACHIO_MCLK_DAC_CLK>;
+			mclk-fs = <256 384 512 768>;
+			mclk-min-freq = <2048000>;
+			mclk-max-freq = <36864000>;
+			sound-dai = <&pcm3168a_2 1>;
+			frame-master;
+			bitclock-master;
+		};
+	};
+};
diff --git a/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
new file mode 100644
index 0000000..2e5e493
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/img,pistachio-event-timer.txt
@@ -0,0 +1,63 @@
+Imagination Technologies Pistachio Event Timer
+
+Required properties:
+
+  - compatible : Compatible list, must contain "img,pistachio-event-timer"
+
+  - reg : Offset and length of the register set for the device
+
+  - interrupts : Must contain an entry for each of the three interrupts below.
+		 Order must also match the below:
+
+		 Internal interrupt 1
+		 Internal interrupt 2
+		 Internal interrupt 3
+		 Event trigger 0
+		 Event trigger 1
+
+  - #clock-cells : Must be 0
+
+  - clocks : Must contain an entry for each entry in clock-names
+	See ../clock/clock-bindings.txt for details
+
+  - clock-names : Must include the following entries:
+	"sys"	The system clock
+	"ref0"	Reference clock 0
+	"ref1"	Reference clock 1
+	"pll"	Audio PLL
+
+  - img,clk-select : Reference select
+
+  - img,cr-periph : phandle of the peripheral control syscon node which
+		    contains the event timer external source bank select
+		    register
+
+  - img,ext-src-bank : GPIO bank selection for external source. For this source
+		       to function correctly, no other input gpios must be used
+		       within the selected GPIO bank
+
+Optional properties:
+
+  - img,clk-rate : Initial internal clock rate
+
+Example:
+
+event_timer: event_timer@18102300 {
+	compatible = "img,pistachio-event-timer";
+	reg = <0x18102300 0x400>;
+	assigned-clocks = <&clk_core CLK_EVENT_TIMER_MUX>;
+	assigned-clock-parents = <&clk_core CLK_AUDIO_PLL_MUX>;
+	interrupts = <GIC_SHARED 53 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 54 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 55 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 56 IRQ_TYPE_LEVEL_HIGH>,
+		     <GIC_SHARED 57 IRQ_TYPE_LEVEL_HIGH>;
+	#clock-cells = <0>;
+	clocks = <&clk_core SYS_CLK_EVENT_TIMER>,
+		 <&clk_core CLK_AUDIO>,
+		 <&clk_core CLK_EVENT_TIMER>,
+		 <&clk_core CLK_AUDIO_PLL>;
+	clock-names = "sys","ref0","ref1", "pll";
+	img,clk-select = <1>;
+	img,clk-rate = <12288000>;
+};
diff --git a/include/dt-bindings/sound/pistachio-audio.h b/include/dt-bindings/sound/pistachio-audio.h
new file mode 100644
index 0000000..77ee75a
--- /dev/null
+++ b/include/dt-bindings/sound/pistachio-audio.h
@@ -0,0 +1,8 @@
+#ifndef __PISTACHIO_BUB_AUDIO_H
+#define __PISTACHIO_BUB_AUDIO_H
+
+#define PISTACHIO_MCLK_NONE		0
+#define PISTACHIO_MCLK_I2S		1
+#define PISTACHIO_MCLK_DAC		2
+
+#endif
diff --git a/include/sound/dmaengine_pcm.h b/include/sound/dmaengine_pcm.h
index 67be244..78b9174 100644
--- a/include/sound/dmaengine_pcm.h
+++ b/include/sound/dmaengine_pcm.h
@@ -35,6 +35,7 @@ snd_pcm_substream_to_dma_direction(const struct snd_pcm_substream *substream)
 
 int snd_hwparams_to_dma_slave_config(const struct snd_pcm_substream *substream,
 	const struct snd_pcm_hw_params *params, struct dma_slave_config *slave_config);
+int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream);
 int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd);
 snd_pcm_uframes_t snd_dmaengine_pcm_pointer(struct snd_pcm_substream *substream);
 snd_pcm_uframes_t snd_dmaengine_pcm_pointer_no_residue(struct snd_pcm_substream *substream);
@@ -111,6 +112,11 @@ void snd_dmaengine_pcm_set_config_from_dai_data(
  * The PCM streams have custom channel names specified.
  */
 #define SND_DMAENGINE_PCM_FLAG_CUSTOM_CHANNEL_NAME BIT(4)
+/*
+ * DMA needs to be started early when start_at is used (eg to allow pre-loading
+ * of internal fifos before assertion of an enable signal)
+ */
+#define SND_DMAENGINE_PCM_FLAG_EARLY_START BIT(5)
 
 /**
  * struct snd_dmaengine_pcm_config - Configuration data for dmaengine based PCM
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index af1fb37..1392bce 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -30,6 +30,9 @@
 #include <linux/mm.h>
 #include <linux/bitops.h>
 #include <linux/pm_qos.h>
+#if defined(CONFIG_HIGH_RES_TIMERS)
+#include <linux/hrtimer.h>
+#endif
 
 #define snd_pcm_substream_chip(substream) ((substream)->private_data)
 #define snd_pcm_chip(pcm) ((pcm)->private_data)
@@ -73,6 +76,9 @@ struct snd_pcm_ops {
 	int (*hw_free)(struct snd_pcm_substream *substream);
 	int (*prepare)(struct snd_pcm_substream *substream);
 	int (*trigger)(struct snd_pcm_substream *substream, int cmd);
+	int (*start_at)(struct snd_pcm_substream *substream,
+		int audio_clock_type, const struct timespec *ts);
+	int (*start_at_abort)(struct snd_pcm_substream *substream);
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream);
 	int (*get_time_info)(struct snd_pcm_substream *substream,
 			struct timespec *system_ts, struct timespec *audio_ts,
@@ -422,6 +428,7 @@ struct snd_pcm_runtime {
 	/* -- OSS things -- */
 	struct snd_pcm_oss_runtime oss;
 #endif
+
 };
 
 struct snd_pcm_group {		/* keep linked substreams */
@@ -482,6 +489,16 @@ struct snd_pcm_substream {
 #endif /* CONFIG_SND_VERBOSE_PROCFS */
 	/* misc flags */
 	unsigned int hw_opened: 1;
+	/* start at wait queue */
+	wait_queue_head_t start_at_wait;
+	/* start at status info */
+	bool start_at_pending;
+	/* Clock type for pending start at */
+	int start_at_clock_class;
+#ifdef CONFIG_HIGH_RES_TIMERS
+	/* start at timer for use with system startat */
+	struct hrtimer start_at_timer;
+#endif
 };
 
 #define SUBSTREAM_BUSY(substream) ((substream)->ref_count > 0)
@@ -564,6 +581,10 @@ int snd_pcm_info_user(struct snd_pcm_substream *substream,
 int snd_pcm_status(struct snd_pcm_substream *substream,
 		   struct snd_pcm_status *status);
 int snd_pcm_start(struct snd_pcm_substream *substream);
+int snd_pcm_pre_start(struct snd_pcm_substream *substream, int state);
+int snd_pcm_do_start(struct snd_pcm_substream *substream, int state);
+void snd_pcm_undo_start(struct snd_pcm_substream *substream, int state);
+void snd_pcm_post_start(struct snd_pcm_substream *substream, int state);
 int snd_pcm_stop(struct snd_pcm_substream *substream, snd_pcm_state_t status);
 int snd_pcm_drain_done(struct snd_pcm_substream *substream);
 int snd_pcm_stop_xrun(struct snd_pcm_substream *substream);
@@ -1086,6 +1107,9 @@ snd_pcm_sframes_t snd_pcm_lib_writev(struct snd_pcm_substream *substream,
 snd_pcm_sframes_t snd_pcm_lib_readv(struct snd_pcm_substream *substream,
 				    void __user **bufs, snd_pcm_uframes_t frames);
 
+void snd_pcm_start_at_trigger(struct snd_pcm_substream *substream);
+void snd_pcm_start_at_cleanup(struct snd_pcm_substream *substream);
+
 extern const struct snd_pcm_hw_constraint_list snd_pcm_known_rates;
 
 int snd_pcm_limit_hw_rates(struct snd_pcm_runtime *runtime);
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index 964b7de..dc03bba 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -205,6 +205,11 @@ struct snd_soc_dai_ops {
 	 */
 	snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *,
 		struct snd_soc_dai *);
+
+	int (*start_at)(struct snd_pcm_substream *, struct snd_soc_dai *,
+		int, const struct timespec *);
+	int (*start_at_abort)(struct snd_pcm_substream *,
+		struct snd_soc_dai *);
 };
 
 /*
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 4f1c784..7ca11e3 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -759,6 +759,9 @@ struct snd_soc_ops {
 	int (*hw_free)(struct snd_pcm_substream *);
 	int (*prepare)(struct snd_pcm_substream *);
 	int (*trigger)(struct snd_pcm_substream *, int);
+	int (*start_at)(struct snd_pcm_substream *, int,
+		const struct timespec *);
+	int (*start_at_abort)(struct snd_pcm_substream *);
 };
 
 struct snd_soc_compr_ops {
diff --git a/include/uapi/sound/asound.h b/include/uapi/sound/asound.h
index be353a7..09d4a2a 100644
--- a/include/uapi/sound/asound.h
+++ b/include/uapi/sound/asound.h
@@ -298,6 +298,7 @@ typedef int __bitwise snd_pcm_state_t;
 #define	SNDRV_PCM_STATE_PAUSED		((__force snd_pcm_state_t) 6) /* stream is paused */
 #define	SNDRV_PCM_STATE_SUSPENDED	((__force snd_pcm_state_t) 7) /* hardware is suspended */
 #define	SNDRV_PCM_STATE_DISCONNECTED	((__force snd_pcm_state_t) 8) /* hardware is disconnected */
+#define	SNDRV_PCM_STATE_STARTING	((__force snd_pcm_state_t) 9) /* stream start has been delegated to the kernel */
 #define	SNDRV_PCM_STATE_LAST		SNDRV_PCM_STATE_DISCONNECTED
 
 enum {
@@ -508,6 +509,18 @@ enum {
 	SNDRV_PCM_TSTAMP_TYPE_LAST = SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW,
 };
 
+enum {
+	SNDRV_PCM_CLOCK_CLASS_SYSTEM = 0,
+	SNDRV_PCM_CLOCK_CLASS_AUDIO,
+	SNDRV_PCM_CLOCK_CLASS_LAST = SNDRV_PCM_CLOCK_CLASS_AUDIO,
+};
+
+struct snd_startat {
+	int clock_class;
+	int clock_type;
+	struct timespec start_time;
+};
+
 /* channel positions */
 enum {
 	SNDRV_CHMAP_UNKNOWN = 0,
@@ -587,6 +600,8 @@ enum {
 #define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)
 #define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)
 #define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)
+#define SNDRV_PCM_IOCTL_START_AT        _IOW('A', 0x62, struct snd_startat)
+
 
 /*****************************************************************************
  *                                                                           *
diff --git a/kernel/time/clocksource.c b/kernel/time/clocksource.c
index 7e4fad7..d54de65 100644
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@ -89,6 +89,7 @@ clocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)
 	*mult = tmp;
 	*shift = sft;
 }
+EXPORT_SYMBOL(clocks_calc_mult_shift);
 
 /*[Clocksource internal variables]---------
  * curr_clocksource:
diff --git a/sound/core/pcm.c b/sound/core/pcm.c
index 8e980aa..23379a7 100644
--- a/sound/core/pcm.c
+++ b/sound/core/pcm.c
@@ -489,7 +489,8 @@ static void snd_pcm_xrun_injection_write(struct snd_info_entry *entry,
 
 	snd_pcm_stream_lock_irq(substream);
 	runtime = substream->runtime;
-	if (runtime && runtime->status->state == SNDRV_PCM_STATE_RUNNING)
+	if (runtime && (runtime->status->state == SNDRV_PCM_STATE_RUNNING ||
+			runtime->status->state == SNDRV_PCM_STATE_STARTING))
 		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
 	snd_pcm_stream_unlock_irq(substream);
 }
@@ -746,6 +747,7 @@ int snd_pcm_new_stream(struct snd_pcm *pcm, int stream, int substream_count)
 		INIT_LIST_HEAD(&substream->self_group.substreams);
 		list_add_tail(&substream->link_list, &substream->self_group.substreams);
 		atomic_set(&substream->mmap_count, 0);
+		init_waitqueue_head(&substream->start_at_wait);
 		prev = substream;
 	}
 	return 0;
diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c
index 1f64ab0..63451e3 100644
--- a/sound/core/pcm_compat.c
+++ b/sound/core/pcm_compat.c
@@ -316,6 +316,25 @@ static int snd_pcm_status_user_x32(struct snd_pcm_substream *substream,
 }
 #endif /* CONFIG_X86_X32 */
 
+struct snd_startat32 {
+	u32 clock_class;
+	u32 clock_type;
+	struct compat_timespec start_time;
+} __packed;
+
+static int snd_pcm_start_at_compat(struct snd_pcm_substream *substream,
+					struct snd_startat32 __user *_start_at)
+{
+	struct snd_startat start_at;
+
+	if (get_user(start_at.clock_class, &_start_at.clock_class) ||
+	    get_user(start_at.clock_type, &_start_at.clock_type) ||
+	    compat_get_timespec(&start_at.start_time, &_start_at.start_time))
+		return -EFAULT;
+
+	return snd_pcm_start_at(substream, &start_at);
+}
+
 /* both for HW_PARAMS and HW_REFINE */
 static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,
 					  int refine, 
@@ -653,6 +672,7 @@ enum {
 	SNDRV_PCM_IOCTL_STATUS_EXT_X32 = _IOWR('A', 0x24, struct snd_pcm_status_x32),
 	SNDRV_PCM_IOCTL_SYNC_PTR_X32 = _IOWR('A', 0x23, struct snd_pcm_sync_ptr_x32),
 #endif /* CONFIG_X86_X32 */
+	SNDRV_PCM_IOCTL_START_AT32 = _IOWR('A', 0x62, struct snd_startat32)
 };
 
 static long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned long arg)
@@ -734,6 +754,8 @@ static long snd_pcm_ioctl_compat(struct file *file, unsigned int cmd, unsigned l
 	case SNDRV_PCM_IOCTL_CHANNEL_INFO_X32:
 		return snd_pcm_ioctl_channel_info_x32(substream, argp);
 #endif /* CONFIG_X86_X32 */
+	case SNDRV_PCM_IOCTL_START_AT32:
+		return snd_pcm_start_at_compat(substream, argp);
 	}
 
 	return -ENOIOCTLCMD;
diff --git a/sound/core/pcm_dmaengine.c b/sound/core/pcm_dmaengine.c
index 8eb58c7..b39e81a 100644
--- a/sound/core/pcm_dmaengine.c
+++ b/sound/core/pcm_dmaengine.c
@@ -149,7 +149,7 @@ static void dmaengine_pcm_dma_complete(void *arg)
 	snd_pcm_period_elapsed(substream);
 }
 
-static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
+int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 {
 	struct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);
 	struct dma_chan *chan = prtd->dma_chan;
@@ -177,6 +177,7 @@ static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 
 	return 0;
 }
+EXPORT_SYMBOL_GPL(dmaengine_pcm_prepare_and_submit);
 
 /**
  * snd_dmaengine_pcm_trigger - dmaengine based PCM trigger implementation
diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c
index bb12615..629d828 100644
--- a/sound/core/pcm_lib.c
+++ b/sound/core/pcm_lib.c
@@ -2025,6 +2025,7 @@ static snd_pcm_sframes_t snd_pcm_lib_write1(struct snd_pcm_substream *substream,
 	snd_pcm_stream_lock_irq(substream);
 	switch (runtime->status->state) {
 	case SNDRV_PCM_STATE_PREPARED:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_RUNNING:
 	case SNDRV_PCM_STATE_PAUSED:
 		break;
@@ -2251,6 +2252,7 @@ static snd_pcm_sframes_t snd_pcm_lib_read1(struct snd_pcm_substream *substream,
 		break;
 	case SNDRV_PCM_STATE_DRAINING:
 	case SNDRV_PCM_STATE_RUNNING:
+	case SNDRV_PCM_STATE_STARTING:
 	case SNDRV_PCM_STATE_PAUSED:
 		break;
 	case SNDRV_PCM_STATE_XRUN:
diff --git a/sound/soc/img/Kconfig b/sound/soc/img/Kconfig
index 857a951..00bb4f2 100644
--- a/sound/soc/img/Kconfig
+++ b/sound/soc/img/Kconfig
@@ -50,3 +50,47 @@ config SND_SOC_IMG_PISTACHIO_INTERNAL_DAC
 	help
 	  Say Y or M if you want to add support for Pistachio internal DAC
 	  driver for Imagination Technologies Pistachio internal DAC device.
+
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	tristate "Support for Pistachio SoC Event Timer Driver"
+	depends on SND_SOC_IMG
+	help
+	  Say Y or M if you want to add support for Pistachio event timer
+	  driver for Imagination Technologies Pistachio event timer device.
+
+choice
+	prompt "Pistachio Event Timer Time Units"
+	depends on SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	default SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU if ATU
+	help
+	  Selects the time units used by the Pistachio Event Timer
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU
+	tristate "Pistachio SoC Event Timer uses ATU units"
+	depends on ATU
+	help
+	  ATU units are used (atu time maintained by ATU driver)
+
+config SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL
+	tristate "Pistachio SoC Event Timer uses local units"
+	help
+	  Local units are used (nanoseconds since event timer probe)
+
+endchoice
+
+config SND_SOC_IMG_PISTACHIO
+	tristate "Audio support for Pistachio SoC"
+	depends on SND_SOC_IMG
+	select SND_SOC_IMG_I2S_IN
+	select SND_SOC_IMG_I2S_OUT
+	select SND_SOC_IMG_PARALLEL_OUT
+	select SND_SOC_IMG_SPDIF_IN
+	select SND_SOC_IMG_SPDIF_OUT
+	select SND_SOC_IMG_PISTACHIO_EVENT_TIMER
+	select SND_SOC_PCM3168A_I2C
+	select SND_SOC_PCM3168A_SPI
+	select SND_SOC_PCM3060_I2C
+	select SND_SOC_PCM3060_SPI
+	help
+	  Audio support for Imagination Technologies Pistachio Bring-Up Board
diff --git a/sound/soc/img/Makefile b/sound/soc/img/Makefile
index 0508c1c..b58a039 100644
--- a/sound/soc/img/Makefile
+++ b/sound/soc/img/Makefile
@@ -5,3 +5,8 @@ obj-$(CONFIG_SND_SOC_IMG_SPDIF_IN) += img-spdif-in.o
 obj-$(CONFIG_SND_SOC_IMG_SPDIF_OUT) += img-spdif-out.o
 
 obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_INTERNAL_DAC) += pistachio-internal-dac.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER) += pistachio-event-timer.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER_ATU) += pistachio-event-timer-atu.o
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO_EVENT_TIMER_LOCAL) += pistachio-event-timer-local.o
+
+obj-$(CONFIG_SND_SOC_IMG_PISTACHIO) += pistachio.o
diff --git a/sound/soc/img/pistachio-event-timer-atu.c b/sound/soc/img/pistachio-event-timer-atu.c
new file mode 100644
index 0000000..698b6ec9
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-atu.c
@@ -0,0 +1,68 @@
+/*
+ * Pistachio event timer ATU time units
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/atu_clk.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return atu_get_current_time();
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_get_time);
+
+u64 pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return atu_get_current_time();
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time);
+
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time, u32 *reg,
+				u64 min_time_delta)
+{
+	return atu_to_frc(time, reg, min_time_delta);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_time_to_reg);
+
+int pistachio_evt_init(struct pistachio_evt *evt)
+{
+	return atu_cyclecounter_register(&evt->cc, evt->audio_pll);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_init);
+
+void pistachio_evt_deinit(struct pistachio_evt *evt)
+{
+	atu_cyclecounter_unregister(&evt->cc);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_deinit);
diff --git a/sound/soc/img/pistachio-event-timer-internal.h b/sound/soc/img/pistachio-event-timer-internal.h
new file mode 100644
index 0000000..afc6928
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-internal.h
@@ -0,0 +1,70 @@
+/*
+ * Imagination Technologies Pistachio Event Timer Internal Header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __IMG_PISTACHIO_EVT_INTERNAL_H__
+#define __IMG_PISTACHIO_EVT_INTERNAL_H__
+
+enum pistachio_evt_state {
+	PISTACHIO_EVT_STATE_IDLE = 0,
+	PISTACHIO_EVT_STATE_ACTIVE_FIRST,
+	PISTACHIO_EVT_STATE_ACTIVE_SECOND,
+	PISTACHIO_EVT_STATE_ACTIVE_THIRD,
+	PISTACHIO_EVT_STATE_COMPLETE
+};
+
+struct pistachio_evt_callback {
+	u64 trigger_time;
+	u32 cyc;
+	void (*callback)(struct pistachio_evt *, void *);
+	void *context;
+};
+
+struct pistachio_evt_measurement {
+	enum pistachio_evt_state state;
+	void (*callback)(void *);
+	void *context;
+};
+
+struct pistachio_evt {
+	struct list_head list;
+	spinlock_t lock;
+	struct device *dev;
+	struct device_node *np;
+	void __iomem *base;
+	struct clk *audio_pll;
+	struct clk *clk_sys;
+	struct clk *clk_ref_a;
+	struct clk *clk_ref_b;
+	const char *ref_names[2];
+	struct clk *clk_ref_internal;
+	struct cyclecounter cc;
+	struct timecounter tc;
+	struct notifier_block evt_clk_notifier;
+	struct hrtimer poll_timer;
+	ktime_t quarter_rollover;
+	unsigned long sys_rate;
+	struct pistachio_evt_callback trigger_cbs[PISTACHIO_EVT_NUM_ENABLES];
+	struct pistachio_evt_measurement sample_rates[PISTACHIO_EVT_MAX_SOURCES];
+	struct pistachio_evt_measurement phase_difference;
+};
+
+/* Call with lock held */
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt);
+/* Call without lock held */
+u64 pistachio_evt_get_time(struct pistachio_evt *evt);
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time,
+				u32 *reg, u64 min_time_delta);
+int pistachio_evt_init(struct pistachio_evt *evt);
+void pistachio_evt_deinit(struct pistachio_evt *evt);
+
+void pistachio_evt_clk_rate_change(struct pistachio_evt *evt);
+#endif
diff --git a/sound/soc/img/pistachio-event-timer-local.c b/sound/soc/img/pistachio-event-timer-local.c
new file mode 100644
index 0000000..e775a7a
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer-local.c
@@ -0,0 +1,186 @@
+/*
+ * Pistachio event timer local time units
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/hrtimer.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/atu_clk.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+static u64 _pistachio_evt_get_time_cyc(struct pistachio_evt *evt, u32 *cyc)
+{
+	u64 ret;
+
+	ret = timecounter_read(&evt->tc);
+	if (cyc)
+		*cyc = evt->tc.cycle_last;
+
+	return ret;
+}
+
+static u64 pistachio_evt_get_time_cyc(struct pistachio_evt *evt, u32 *cyc)
+{
+	unsigned long flags;
+	u64 ret;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	ret = _pistachio_evt_get_time_cyc(evt, cyc);
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+
+u64 _pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return _pistachio_evt_get_time_cyc(evt, NULL);
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_get_time);
+
+u64 pistachio_evt_get_time(struct pistachio_evt *evt)
+{
+	return pistachio_evt_get_time_cyc(evt, NULL);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time);
+
+int pistachio_evt_time_to_reg(struct pistachio_evt *evt, u64 time, u32 *reg,
+				u64 min_time_delta)
+{
+	u64 tmp;
+	u32 cyc;
+
+	tmp = _pistachio_evt_get_time_cyc(evt, &cyc);
+
+	/* Trigger in the past or too close to current time? */
+	if (time < (tmp + min_time_delta))
+		return -ETIME;
+
+	/*
+	 * Convert ns difference between current time and trigger time
+	 * to event timer cycles
+	 */
+	tmp = (time - tmp) << evt->cc.shift;
+	do_div(tmp, evt->cc.mult);
+
+	/* Trigger too far into the future (cyc value would be ambiguous)? */
+	if (tmp > evt->cc.mask)
+		return -ETIME;
+
+	/* Calculate cycle value for trigger */
+	cyc = (cyc + tmp) & evt->cc.mask;
+
+	/* Final time check before fast write operations */
+	tmp = _pistachio_evt_get_time_cyc(evt, &cyc);
+	if (time < (tmp + min_time_delta))
+		return -ETIME;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_time_to_reg);
+
+static enum hrtimer_restart pistachio_evt_poll(struct hrtimer *tmr)
+{
+	struct pistachio_evt *evt;
+	u64 tmp;
+
+	evt = container_of(tmr, struct pistachio_evt, poll_timer);
+
+	tmp = pistachio_evt_get_time(evt);
+
+	hrtimer_forward(&evt->poll_timer,
+			hrtimer_get_expires(&evt->poll_timer),
+			evt->quarter_rollover);
+
+	return HRTIMER_RESTART;
+}
+
+static void pistachio_evt_start_poll_timer(struct pistachio_evt *evt)
+{
+	ktime_t ks;
+
+	ks = ktime_get();
+	ks = ktime_add(ks, evt->quarter_rollover);
+
+	hrtimer_start(&evt->poll_timer, ks, HRTIMER_MODE_ABS);
+}
+
+static int pistachio_evt_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	struct pistachio_evt *evt;
+
+	evt = container_of(nb, struct pistachio_evt, evt_clk_notifier);
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		pistachio_evt_get_time_cyc(evt, NULL);
+		return NOTIFY_OK;
+	case POST_RATE_CHANGE:
+		hrtimer_cancel(&evt->poll_timer);
+		pistachio_evt_clk_rate_change(evt);
+		pistachio_evt_get_time_cyc(evt, NULL);
+		pistachio_evt_start_poll_timer(evt);
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+int pistachio_evt_init(struct pistachio_evt *evt)
+{
+	int ret;
+
+	timecounter_init(&evt->tc, (const struct cyclecounter *)&evt->cc, 0);
+
+	hrtimer_init(&evt->poll_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	evt->poll_timer.function = pistachio_evt_poll;
+
+	pistachio_evt_start_poll_timer(evt);
+
+	evt->evt_clk_notifier.notifier_call = pistachio_evt_clk_notifier_cb;
+
+	ret = clk_notifier_register(evt->clk_ref_internal,
+					&evt->evt_clk_notifier);
+
+	if (ret)
+		hrtimer_cancel(&evt->poll_timer);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_init);
+
+void pistachio_evt_deinit(struct pistachio_evt *evt)
+{
+	clk_notifier_unregister(evt->clk_ref_internal, &evt->evt_clk_notifier);
+	hrtimer_cancel(&evt->poll_timer);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_deinit);
diff --git a/sound/soc/img/pistachio-event-timer.c b/sound/soc/img/pistachio-event-timer.c
new file mode 100644
index 0000000..4f2c750
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer.c
@@ -0,0 +1,995 @@
+/*
+ * Pistachio event timer driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/hrtimer.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/timecounter.h>
+
+#include <linux/mfd/syscon.h>
+
+#include "pistachio-event-timer.h"
+#include "pistachio-event-timer-internal.h"
+
+#define	PISTACHIO_EVT_FIFO_DEPTH		16
+
+#define PISTACHIO_EVT_COUNTER			0x0
+#define PISTACHIO_EVT_COUNTER_MASK		0x3fffffff
+#define PISTACHIO_EVT_COUNTER_ENABLE_MASK	0x80000000
+
+#define PISTACHIO_EVT_TIMESTAMP_STS		0x4
+
+#define PISTACHIO_EVT_TIMESTAMP_CLR		0x8
+
+#define PISTACHIO_EVT_CLKSRC_SELECT		0xc
+#define PISTACHIO_EVT_CLKSRC_SELECT_SHIFT	0
+#define PISTACHIO_EVT_CLKSRC_SELECT_WIDTH	1
+
+#define PISTACHIO_EVT_SOURCE_INTERNAL_START	0x10
+#define PISTACHIO_EVT_SOURCE_INTERNAL_MASK	0xf
+
+#define PISTACHIO_EVT_TIMESTAMP_START		0x40
+#define PISTACHIO_EVT_TIMESTAMP_MASK		PISTACHIO_EVT_COUNTER_MASK
+
+#define PISTACHIO_EVT_TIMER_ENABLE		0x100
+#define PISTACHIO_EVT_TIMER_ENABLE_MASK		0x1
+
+#define PISTACHIO_EVT_SOURCES			0x108
+#define PISTACHIO_EVT_SOURCES_SHIFT		16
+#define	PISTACHIO_EVT_SOURCES_MASK_LSB		0xffffUL
+
+#define PISTACHIO_EVT_PHASE_FIFO		0x110
+
+#define	PISTACHIO_EVT_SAMPLE_FIFO(id)		(0x114 + ((id) * 0x4))
+
+#define PISTACHIO_EVT_EVENT_CTL			0x120
+#define PISTACHIO_EVT_EVENT_CTL_MASK		0x3
+#define PISTACHIO_EVT_EVENT_CTL_WIDTH		2
+
+#define PISTACHIO_EVT_TIME_REG(en)		(0x130 + ((en) * 0x4))
+
+#define PISTACHIO_EVT_INT_STATUS		0x170
+
+#define PISTACHIO_EVT_INT_ENABLE		0x174
+
+#define PISTACHIO_EVT_INT_CLEAR			0x178
+
+#define	PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK	BIT(5)
+#define	PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK	BIT(9)
+#define	PISTACHIO_EVT_INT_PHASE_FNE_MASK	BIT(1)
+
+#define	PISTACHIO_EVT_EXT_SRC_REG		0x158
+#define	PISTACHIO_EVT_EXT_SRC_MASK		0xf
+#define	PISTACHIO_EVT_EXT_SRC_NUM_BANKS		7
+
+#define	PISTACHIO_EVT_MIN_EVENT_DELTA_NS	10000
+
+static LIST_HEAD(pistachio_evt_list);
+static DEFINE_SPINLOCK(pistachio_evt_list_spinlock);
+
+static inline u32 pistachio_evt_readl(struct pistachio_evt *evt, u32 reg)
+{
+	return readl(evt->base + reg);
+}
+
+static inline void pistachio_evt_writel(struct pistachio_evt *evt,
+					u32 val, u32 reg)
+{
+	writel(val, evt->base + reg);
+}
+
+static inline void pistachio_evt_stop_count(struct pistachio_evt *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
+	reg &= ~PISTACHIO_EVT_COUNTER_ENABLE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static inline void pistachio_evt_start_count(struct pistachio_evt *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
+	reg |= PISTACHIO_EVT_COUNTER_ENABLE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_COUNTER);
+}
+
+static inline u32 pistachio_evt_get_count(struct pistachio_evt *evt)
+{
+	u32 reg = pistachio_evt_readl(evt, PISTACHIO_EVT_COUNTER);
+
+	return reg & PISTACHIO_EVT_COUNTER_MASK;
+}
+
+static cycle_t pistachio_evt_cc_read(const struct cyclecounter *cc)
+{
+	struct pistachio_evt *evt;
+
+	evt = container_of(cc, struct pistachio_evt, cc);
+
+	return (cycle_t)pistachio_evt_get_count(evt);
+}
+
+void pistachio_evt_get_time_ts(struct pistachio_evt *evt,
+				struct timespec *ts)
+{
+	u64 tmp;
+
+	tmp = pistachio_evt_get_time(evt);
+	ts->tv_nsec = do_div(tmp, NSEC_PER_SEC);
+	ts->tv_sec = tmp;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_time_ts);
+
+static inline bool pistachio_evt_bad_event(enum pistachio_evt_enable event)
+{
+	switch (event) {
+	case PISTACHIO_EVT_ENABLE_PARALLEL_OUT:
+	case PISTACHIO_EVT_ENABLE_I2S_OUT:
+	case PISTACHIO_EVT_ENABLE_SPDIF_OUT:
+	case PISTACHIO_EVT_ENABLE_EXTERNAL:
+		return false;
+	default:
+		return true;
+	}
+}
+
+static struct pistachio_evt_callback *pistachio_evt_get_next_trigger(
+		struct pistachio_evt *evt, u64 *p_next_trigger)
+{
+	u64 next_trigger, tmp;
+	int i;
+	struct pistachio_evt_callback *cbr = NULL, *cb;
+
+	cb = &evt->trigger_cbs[0];
+	next_trigger = ULLONG_MAX;
+
+	for (i = 0; i < PISTACHIO_EVT_NUM_ENABLES; i++, cb++) {
+		if (!pistachio_evt_bad_event(i)) {
+			tmp = cb->trigger_time;
+			if (tmp && (tmp < next_trigger)) {
+				next_trigger = tmp;
+				cbr = cb;
+			}
+		}
+	}
+
+	*p_next_trigger = next_trigger;
+
+	return cbr;
+}
+
+struct pistachio_evt *pistachio_evt_get(struct device_node *np)
+{
+	struct pistachio_evt *evt, *ret = ERR_PTR(-EPROBE_DEFER);
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_for_each_entry(evt, &pistachio_evt_list, list) {
+		if (evt->np == np) {
+			ret = evt;
+			break;
+		}
+	}
+	spin_unlock(&pistachio_evt_list_spinlock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get);
+
+void _pistachio_evt_disable_event(struct pistachio_evt *evt,
+		enum pistachio_evt_enable event)
+{
+	u32 reg;
+
+	dev_dbg(evt->dev, "Disable event %u\n", (unsigned int)event);
+
+	if (pistachio_evt_bad_event(event)) {
+		dev_err(evt->dev, "Disable event %u failed (bad event %u)\n",
+			(unsigned int)event, (unsigned int)event);
+		return;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	evt->trigger_cbs[event].trigger_time = 0;
+}
+EXPORT_SYMBOL_GPL(_pistachio_evt_disable_event);
+
+void pistachio_evt_disable_event(struct pistachio_evt *evt,
+		enum pistachio_evt_enable event)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	_pistachio_evt_disable_event(evt, event);
+	spin_unlock_irqrestore(&evt->lock, flags);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_disable_event);
+
+int pistachio_evt_set_event(struct pistachio_evt *evt,
+		enum pistachio_evt_enable event, enum pistachio_evt_type type,
+		struct timespec *ts,
+		void (*event_trigger_callback)(struct pistachio_evt *, void *),
+		void *context)
+{
+	u32 reg, cyc, event_reg_addr, irq_reg_addr;
+	u64 trigger_time, next_trigger;
+	unsigned long flags;
+	struct pistachio_evt_callback *cb;
+	int ret;
+
+	dev_dbg(evt->dev, "Set event %u type %u time %u,%ld\n",
+		(unsigned int)event, (unsigned int)type,
+		(unsigned int)ts->tv_sec, ts->tv_nsec);
+
+	if (pistachio_evt_bad_event(event)) {
+		dev_err(evt->dev, "Set event %u failed (bad event %u)\n",
+			(unsigned int)event, (unsigned int)event);
+		return -EINVAL;
+	}
+
+	switch (type) {
+	case PISTACHIO_EVT_TYPE_LEVEL:
+	case PISTACHIO_EVT_TYPE_PULSE:
+		break;
+	default:
+		dev_err(evt->dev, "Set event %u failed (bad event type %u)\n",
+			(unsigned int)event, (unsigned int)type);
+		return -EINVAL;
+	}
+
+	if (!ts) {
+		dev_err(evt->dev, "Set event %u failed (ts == NULL)\n",
+			(unsigned int)event);
+		return -EINVAL;
+	}
+
+	event_reg_addr = PISTACHIO_EVT_TIME_REG(event);
+	irq_reg_addr = PISTACHIO_EVT_TIME_REG(PISTACHIO_EVT_ENABLE_IRQ_0);
+
+	trigger_time = (u64)ts->tv_sec * NSEC_PER_SEC + ts->tv_nsec;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	/* Trigger already pending for this event? */
+	if (evt->trigger_cbs[event].trigger_time) {
+		spin_unlock_irqrestore(&evt->lock, flags);
+		dev_err(evt->dev, "Set event %u failed (trigger already pending at %lluns)\n",
+			(unsigned int)event,
+			evt->trigger_cbs[event].trigger_time);
+		return -EINVAL;
+	}
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	/*
+	 * This event may have triggered previously. The control bits need to
+	 * be cleared before programming a new trigger
+	 */
+	reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	reg |= (type << (PISTACHIO_EVT_EVENT_CTL_WIDTH * event));
+
+	ret = pistachio_evt_time_to_reg(evt, trigger_time, &cyc,
+					PISTACHIO_EVT_MIN_EVENT_DELTA_NS);
+	if (ret) {
+		spin_unlock_irqrestore(&evt->lock, flags);
+		dev_err(evt->dev, "Set event %u failed (%d)\n",
+			(unsigned int)event, ret);
+		return ret;
+	}
+
+	pistachio_evt_writel(evt, cyc, event_reg_addr);
+
+	cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
+
+	/*
+	 * No irq trigger currently set or the new trigger time is
+	 * earlier than the next trigger time?
+	 */
+	if (!cb || (next_trigger > trigger_time)) {
+		pistachio_evt_writel(evt, cyc, irq_reg_addr);
+		reg |= PISTACHIO_EVT_TYPE_LEVEL <<
+			(PISTACHIO_EVT_EVENT_CTL_WIDTH *
+			PISTACHIO_EVT_ENABLE_IRQ_0);
+	}
+
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	evt->trigger_cbs[event].callback = event_trigger_callback;
+	evt->trigger_cbs[event].trigger_time = trigger_time;
+	evt->trigger_cbs[event].cyc = cyc;
+	evt->trigger_cbs[event].context = context;
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_event);
+
+static bool pistachio_evt_retrigger(struct pistachio_evt *evt,
+				struct pistachio_evt_callback *cb)
+{
+	u32 reg, trig_reg_addr;
+	u64 cur_time;
+
+	trig_reg_addr = PISTACHIO_EVT_TIME_REG(PISTACHIO_EVT_ENABLE_IRQ_0);
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+
+	reg |= (PISTACHIO_EVT_TYPE_LEVEL <<
+		(PISTACHIO_EVT_EVENT_CTL_WIDTH * PISTACHIO_EVT_ENABLE_IRQ_0));
+
+	pistachio_evt_writel(evt, cb->cyc, trig_reg_addr);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+	cur_time = _pistachio_evt_get_time(evt);
+
+	/* Trigger passed while writing? */
+	if (cb->trigger_time < cur_time)
+		return false;
+
+	return true;
+}
+
+static irqreturn_t pistachio_evt_trigger_0_irq(int irq, void *dev_id)
+{
+	struct pistachio_evt *evt = (struct pistachio_evt *)dev_id;
+	u64 next_trigger, cur_time;
+	struct pistachio_evt_callback *cb;
+	unsigned long flags;
+	u32 reg;
+
+	dev_dbg(evt->dev, "Trigger IRQ\n");
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	while (1) {
+		cb = pistachio_evt_get_next_trigger(evt, &next_trigger);
+
+		/* Disable the irq trigger */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_EVENT_CTL);
+		reg &= ~(PISTACHIO_EVT_EVENT_CTL_MASK <<
+			(PISTACHIO_EVT_EVENT_CTL_WIDTH *
+			PISTACHIO_EVT_ENABLE_IRQ_0));
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_EVENT_CTL);
+
+		if (!cb)
+			break;
+
+		cur_time = _pistachio_evt_get_time(evt);
+
+		if (cur_time >= next_trigger) {
+			if (cb->callback)
+				cb->callback(evt, cb->context);
+			cb->trigger_time = 0;
+		} else if (pistachio_evt_retrigger(evt, cb)) {
+			break;
+		} else {
+			if (cb->callback)
+				cb->callback(evt, cb->context);
+			cb->trigger_time = 0;
+		}
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+int pistachio_evt_set_source(struct pistachio_evt *evt,
+			int id, enum pistachio_evt_source source)
+{
+	unsigned long flags;
+	u32 reg;
+
+	if ((id >= PISTACHIO_EVT_MAX_SOURCES) ||
+			(source >= PISTACHIO_EVT_NUM_SOURCES))
+		return -EINVAL;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SOURCES);
+	reg &= ~(PISTACHIO_EVT_SOURCES_MASK_LSB <<
+		(id * PISTACHIO_EVT_SOURCES_SHIFT));
+	reg |= source << (id * PISTACHIO_EVT_SOURCES_SHIFT);
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_SOURCES);
+
+	/*
+	 * Changing one of the sources invalidates the active sample rate
+	 * measurement for the source in question, and the active phase
+	 * difference measurement, so reset these states and mask the
+	 * interrupts
+	 */
+	evt->sample_rates[id].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	if (id == 0)
+		reg &= ~PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+	else
+		reg &= ~PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_set_source);
+
+int pistachio_evt_get_source(struct pistachio_evt *evt,
+		int id, enum pistachio_evt_source *source)
+{
+	u32 reg;
+
+	if (id >= PISTACHIO_EVT_MAX_SOURCES)
+		return -EINVAL;
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SOURCES);
+
+	*source = (reg >> (id * PISTACHIO_EVT_SOURCES_SHIFT)) &
+		PISTACHIO_EVT_SOURCES_MASK_LSB;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_source);
+
+static void pistachio_evt_clear_fifo(struct pistachio_evt *evt,
+			u32 fifo_offset, u32 mask, bool enable_int)
+{
+	u32 reg;
+
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	if (enable_int)
+		reg |= mask;
+	else
+		reg &= ~mask;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+
+	while (1) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (!(reg & mask))
+			break;
+		reg = pistachio_evt_readl(evt, fifo_offset);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+	}
+}
+
+static void pistachio_evt_new_sr(struct pistachio_evt *evt, int id, u32 mask)
+{
+	u32 reg;
+	enum pistachio_evt_state new_state;
+	struct pistachio_evt_measurement *sr = &evt->sample_rates[id];
+
+	switch (sr->state) {
+	case PISTACHIO_EVT_STATE_ACTIVE_FIRST:
+		/* First sample rate measurement is always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_SAMPLE_FIFO(id));
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (reg & mask)
+			new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		else
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_SECOND;
+		break;
+
+	case PISTACHIO_EVT_STATE_ACTIVE_SECOND:
+		new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		break;
+
+	default:
+		dev_err(evt->dev, "pistachio_evt_new_sr bad state (%d)\n",
+			(int)sr->state);
+		return;
+	}
+
+	if (new_state == PISTACHIO_EVT_STATE_COMPLETE) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		reg &= ~mask;
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		if (sr->callback)
+			sr->callback(sr->context);
+	}
+
+	sr->state = new_state;
+}
+
+static void pistachio_evt_new_pd(struct pistachio_evt *evt)
+{
+	u32 reg;
+	enum pistachio_evt_state new_state;
+	u32 mask = PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	struct pistachio_evt_measurement *pd = &evt->phase_difference;
+
+	switch (pd->state) {
+	case PISTACHIO_EVT_STATE_ACTIVE_FIRST:
+		/* First two phase measurements are always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (!(reg & mask)) {
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_SECOND;
+			break;
+		}
+		/* Fall through */
+	case PISTACHIO_EVT_STATE_ACTIVE_SECOND:
+		/* First two phase measurements are always invalid */
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		if (reg & mask)
+			new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		else
+			new_state = PISTACHIO_EVT_STATE_ACTIVE_THIRD;
+		break;
+
+	case PISTACHIO_EVT_STATE_ACTIVE_THIRD:
+		new_state = PISTACHIO_EVT_STATE_COMPLETE;
+		break;
+
+	default:
+		dev_err(evt->dev, "pistachio_evt_new_pd bad state (%d)\n",
+			(int)pd->state);
+		return;
+	}
+
+	if (new_state == PISTACHIO_EVT_STATE_COMPLETE) {
+		reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		reg &= ~mask;
+		pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+		pistachio_evt_writel(evt, mask, PISTACHIO_EVT_INT_CLEAR);
+		pistachio_evt_writel(evt, 0, PISTACHIO_EVT_INT_CLEAR);
+		if (pd->callback)
+			pd->callback(pd->context);
+	}
+
+	pd->state = new_state;
+}
+
+static irqreturn_t pistachio_evt_general_irq(int irq, void *dev_id)
+{
+	struct pistachio_evt *evt = (struct pistachio_evt *)dev_id;
+	unsigned long flags;
+	u32 mask, i, isr, ier;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	while (1) {
+		isr = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_STATUS);
+		ier = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+		isr &= ier;
+
+		if (!isr)
+			break;
+
+		for (i = 0; i < PISTACHIO_EVT_MAX_SOURCES; i++) {
+			if (i == 0)
+				mask = PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+			else
+				mask = PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+
+			if (isr & mask)
+				pistachio_evt_new_sr(evt, i, mask);
+		}
+
+		if (isr & PISTACHIO_EVT_INT_PHASE_FNE_MASK)
+			pistachio_evt_new_pd(evt);
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+int pistachio_evt_get_sample_rate(struct pistachio_evt *evt, int id,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *context), void *context)
+{
+	unsigned long flags;
+	u32 mask;
+	int ret;
+
+	if (id >= PISTACHIO_EVT_MAX_SOURCES)
+		return -EINVAL;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	switch (evt->sample_rates[id].state) {
+	case PISTACHIO_EVT_STATE_IDLE:
+		if (id == 0)
+			mask = PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+		else
+			mask = PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+
+		pistachio_evt_clear_fifo(evt, PISTACHIO_EVT_SAMPLE_FIFO(id),
+					mask, true);
+
+		ret = -EBUSY;
+		evt->sample_rates[id].state = PISTACHIO_EVT_STATE_ACTIVE_FIRST;
+		evt->sample_rates[id].callback = callback;
+		evt->sample_rates[id].context = context;
+		break;
+
+	case PISTACHIO_EVT_STATE_COMPLETE:
+		*val = pistachio_evt_readl(evt, PISTACHIO_EVT_SAMPLE_FIFO(id));
+		*sys_freq = evt->sys_rate;
+		evt->sample_rates[id].state = PISTACHIO_EVT_STATE_IDLE;
+		ret = 0;
+		break;
+
+	default:
+		ret = -EBUSY;
+		break;
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_sample_rate);
+
+extern int pistachio_evt_get_phase_difference(struct pistachio_evt *evt,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *context), void *context)
+{
+	unsigned long flags;
+	u32 mask;
+	int ret = 0;
+
+	spin_lock_irqsave(&evt->lock, flags);
+
+	switch (evt->phase_difference.state) {
+	case PISTACHIO_EVT_STATE_IDLE:
+		mask = PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+
+		pistachio_evt_clear_fifo(evt, PISTACHIO_EVT_PHASE_FIFO,
+						mask, true);
+
+		ret = -EBUSY;
+		evt->phase_difference.state = PISTACHIO_EVT_STATE_ACTIVE_FIRST;
+		evt->phase_difference.callback = callback;
+		evt->phase_difference.context = context;
+		break;
+
+	case PISTACHIO_EVT_STATE_COMPLETE:
+		*val = pistachio_evt_readl(evt, PISTACHIO_EVT_PHASE_FIFO);
+		*sys_freq = evt->sys_rate;
+		evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+		break;
+
+	default:
+		ret = -EBUSY;
+		break;
+	}
+
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_get_phase_difference);
+
+void pistachio_evt_abort_measurements(struct pistachio_evt *evt)
+{
+	unsigned long flags;
+	u32 reg;
+
+	spin_lock_irqsave(&evt->lock, flags);
+	evt->sample_rates[0].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->sample_rates[1].state = PISTACHIO_EVT_STATE_IDLE;
+	evt->phase_difference.state = PISTACHIO_EVT_STATE_IDLE;
+	reg = pistachio_evt_readl(evt, PISTACHIO_EVT_INT_ENABLE);
+	reg &= ~PISTACHIO_EVT_INT_SAMPLE_0_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_SAMPLE_1_FNE_MASK;
+	reg &= ~PISTACHIO_EVT_INT_PHASE_FNE_MASK;
+	pistachio_evt_writel(evt, reg, PISTACHIO_EVT_INT_ENABLE);
+	spin_unlock_irqrestore(&evt->lock, flags);
+}
+EXPORT_SYMBOL_GPL(pistachio_evt_abort_measurements);
+
+void pistachio_evt_clk_rate_change(struct pistachio_evt *evt)
+{
+	u64 tmp;
+	unsigned long flags;
+	unsigned long rate;
+	ktime_t quarter_rollover;
+	u32 mult, shift, mask;
+
+	dev_dbg(evt->dev, "pistachio_evt_clk_rate_change()\n");
+
+	mask = PISTACHIO_EVT_COUNTER_MASK;
+
+	rate = clk_get_rate(evt->clk_ref_internal);
+
+	tmp = ((u64)mask + 1) * NSEC_PER_SEC;
+	do_div(tmp, rate);
+	tmp >>= 2;
+	quarter_rollover.tv64 = tmp;
+
+	clocks_calc_mult_shift(&mult, &shift, rate,
+			NSEC_PER_SEC, DIV_ROUND_UP(mask, rate));
+
+	spin_lock_irqsave(&evt->lock, flags);
+	evt->quarter_rollover = quarter_rollover;
+	evt->cc.mult = mult;
+	evt->cc.shift = shift;
+	spin_unlock_irqrestore(&evt->lock, flags);
+
+	dev_dbg(evt->dev, "rate %ld cc mult %u shift %u\n", rate, evt->cc.mult,
+			evt->cc.shift);
+}
+
+static int pistachio_evt_driver_probe(struct platform_device *pdev)
+{
+	struct pistachio_evt *evt;
+	int ret, irq;
+	struct device_node *np = pdev->dev.of_node;
+	u32 clk_select, rate, ext_src_bank;
+	struct resource iomem;
+	struct device *dev = &pdev->dev;
+	struct regmap *periph_regs;
+
+	evt = devm_kzalloc(&pdev->dev, sizeof(*evt), GFP_KERNEL);
+	if (!evt)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, evt);
+
+	evt->dev = dev;
+	evt->np = np;
+
+	spin_lock_init(&evt->lock);
+
+	ret = of_address_to_resource(np, 0, &iomem);
+	if (ret) {
+		dev_err(dev, "Could not get IO memory\n");
+		return ret;
+	}
+
+	evt->base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(evt->base))
+		return PTR_ERR(evt->base);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "can't get general irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, pistachio_evt_general_irq,
+				0, pdev->name, evt);
+	if (ret) {
+		dev_err(&pdev->dev, "can't request irq %d\n", irq);
+		return ret;
+	}
+
+	irq = platform_get_irq(pdev, 3);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "can't get trigger 0 irq\n");
+		return irq;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq, pistachio_evt_trigger_0_irq,
+				0, pdev->name, evt);
+	if (ret) {
+		dev_err(&pdev->dev, "can't request irq %d\n", irq);
+		return ret;
+	}
+
+	periph_regs = syscon_regmap_lookup_by_phandle(np, "img,cr-periph");
+	if (IS_ERR(periph_regs))
+		return PTR_ERR(periph_regs);
+
+	if (of_property_read_u32(np, "img,ext-src-bank", &ext_src_bank)) {
+		dev_err(&pdev->dev, "No img,ext-src-bank property\n");
+		return -EINVAL;
+	}
+
+	if (ext_src_bank >= PISTACHIO_EVT_EXT_SRC_NUM_BANKS)
+		return -EINVAL;
+
+	regmap_update_bits(periph_regs, PISTACHIO_EVT_EXT_SRC_REG,
+			PISTACHIO_EVT_EXT_SRC_MASK, ext_src_bank);
+
+	if (of_property_read_u32(np, "img,clk-select", &clk_select)) {
+		dev_err(&pdev->dev, "No img,clk-select property\n");
+		return -EINVAL;
+	}
+
+	if (clk_select > 1)
+		return -EINVAL;
+
+	if (of_property_read_u32(np, "img,clk-rate", &rate))
+		rate = 0;
+
+	evt->audio_pll = devm_clk_get(&pdev->dev, "pll");
+	if (IS_ERR(evt->audio_pll))
+		return PTR_ERR(evt->audio_pll);
+
+	ret = clk_prepare_enable(evt->audio_pll);
+	if (ret)
+		return ret;
+
+	evt->clk_ref_a = devm_clk_get(&pdev->dev, "ref0");
+	if (IS_ERR(evt->clk_ref_a)) {
+		ret = PTR_ERR(evt->audio_pll);
+		goto err_pll;
+	}
+
+	ret = clk_prepare_enable(evt->clk_ref_a);
+	if (ret)
+		goto err_pll;
+
+	evt->clk_ref_b = devm_clk_get(&pdev->dev, "ref1");
+	if (IS_ERR(evt->clk_ref_b)) {
+		ret = PTR_ERR(evt->clk_ref_b);
+		goto err_ref_a;
+	}
+
+	ret = clk_prepare_enable(evt->clk_ref_b);
+	if (ret)
+		goto err_ref_a;
+
+	evt->clk_sys = devm_clk_get(&pdev->dev, "sys");
+	if (IS_ERR(evt->clk_sys)) {
+		ret = PTR_ERR(evt->clk_sys);
+		goto err_ref_b;
+	}
+
+	ret = clk_prepare_enable(evt->clk_sys);
+	if (ret)
+		goto err_ref_b;
+
+	evt->sys_rate = clk_get_rate(evt->clk_sys);
+
+	evt->ref_names[0] = __clk_get_name(evt->clk_ref_a);
+	evt->ref_names[1] = __clk_get_name(evt->clk_ref_b);
+
+	evt->clk_ref_internal = clk_register_mux(NULL, "event_timer_internal",
+		evt->ref_names, 2, CLK_SET_RATE_PARENT |
+		CLK_SET_RATE_NO_REPARENT,
+		evt->base + PISTACHIO_EVT_CLKSRC_SELECT,
+		PISTACHIO_EVT_CLKSRC_SELECT_SHIFT,
+		PISTACHIO_EVT_CLKSRC_SELECT_WIDTH,
+		0, NULL);
+
+	if (IS_ERR(evt->clk_ref_internal)) {
+		ret = PTR_ERR(evt->clk_ref_internal);
+		goto err_sys;
+	}
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+			evt->clk_ref_internal);
+	if (ret)
+		goto err_mux;
+
+	if (clk_select == 0)
+		ret = clk_set_parent(evt->clk_ref_internal, evt->clk_ref_a);
+	else
+		ret = clk_set_parent(evt->clk_ref_internal, evt->clk_ref_b);
+
+	if (ret)
+		goto err_clkp;
+
+	if (rate) {
+		ret = clk_set_rate(evt->clk_ref_internal, rate);
+		if (ret)
+			goto err_clkp;
+	}
+
+	evt->cc.mask = PISTACHIO_EVT_COUNTER_MASK;
+	evt->cc.read = pistachio_evt_cc_read;
+
+	pistachio_evt_writel(evt, PISTACHIO_EVT_TIMER_ENABLE_MASK,
+			PISTACHIO_EVT_TIMER_ENABLE);
+
+	pistachio_evt_start_count(evt);
+
+	pistachio_evt_clk_rate_change(evt);
+
+	ret = pistachio_evt_init(evt);
+	if (ret)
+		goto err_count;
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_add(&evt->list, &pistachio_evt_list);
+	spin_unlock(&pistachio_evt_list_spinlock);
+
+	return 0;
+
+err_count:
+	pistachio_evt_stop_count(evt);
+	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+err_clkp:
+	of_clk_del_provider(np);
+err_mux:
+	clk_unregister(evt->clk_ref_internal);
+err_sys:
+	clk_disable_unprepare(evt->clk_sys);
+err_ref_b:
+	clk_disable_unprepare(evt->clk_ref_b);
+err_ref_a:
+	clk_disable_unprepare(evt->clk_ref_a);
+err_pll:
+	clk_disable_unprepare(evt->audio_pll);
+
+	return ret;
+}
+
+static const struct of_device_id pistachio_evt_of_match[] = {
+	{ .compatible = "img,pistachio-event-timer" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, pistachio_evt_of_match);
+
+static int pistachio_evt_driver_remove(struct platform_device *pdev)
+{
+	struct pistachio_evt *evt = platform_get_drvdata(pdev);
+
+	spin_lock(&pistachio_evt_list_spinlock);
+	list_del(&evt->list);
+	spin_unlock(&pistachio_evt_list_spinlock);
+	pistachio_evt_deinit(evt);
+	pistachio_evt_stop_count(evt);
+	pistachio_evt_writel(evt, 0, PISTACHIO_EVT_TIMER_ENABLE);
+	of_clk_del_provider(evt->dev->of_node);
+	clk_unregister(evt->clk_ref_internal);
+	clk_disable_unprepare(evt->clk_sys);
+	clk_disable_unprepare(evt->clk_ref_b);
+	clk_disable_unprepare(evt->clk_ref_a);
+	clk_disable_unprepare(evt->audio_pll);
+
+	return 0;
+}
+
+static struct platform_driver pistachio_evt_driver = {
+	.driver = {
+		.name = "pistachio-event-timer",
+		.of_match_table = pistachio_evt_of_match,
+	},
+	.probe = pistachio_evt_driver_probe,
+	.remove = pistachio_evt_driver_remove,
+};
+module_platform_driver(pistachio_evt_driver);
+
+MODULE_DESCRIPTION("Event Timer driver");
+MODULE_AUTHOR("Damien Horsley");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/img/pistachio-event-timer.h b/sound/soc/img/pistachio-event-timer.h
new file mode 100644
index 0000000..0f0d4b6
--- /dev/null
+++ b/sound/soc/img/pistachio-event-timer.h
@@ -0,0 +1,82 @@
+/*
+ * Imagination Technologies Pistachio Event Timer Header
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#ifndef __IMG_PISTACHIO_EVT_H__
+#define __IMG_PISTACHIO_EVT_H__
+
+struct pistachio_evt;
+
+enum pistachio_evt_enable {
+	PISTACHIO_EVT_ENABLE_PARALLEL_OUT = 0,
+	PISTACHIO_EVT_ENABLE_I2S_OUT,
+	PISTACHIO_EVT_ENABLE_SPDIF_OUT,
+	PISTACHIO_EVT_ENABLE_IRQ_0,
+	PISTACHIO_EVT_ENABLE_IRQ_1,
+	PISTACHIO_EVT_ENABLE_EXTERNAL,
+	PISTACHIO_EVT_NUM_ENABLES
+};
+
+enum pistachio_evt_type {
+	PISTACHIO_EVT_TYPE_PULSE = 1,
+	PISTACHIO_EVT_TYPE_LEVEL
+};
+
+enum pistachio_evt_source {
+	PISTACHIO_EVT_SOURCE_EXTERNAL = 0,
+	PISTACHIO_EVT_SOURCE_SPDIF_IN,
+	PISTACHIO_EVT_SOURCE_SPDIF_OUT,
+	PISTACHIO_EVT_SOURCE_I2S_IN,
+	PISTACHIO_EVT_SOURCE_I2S_OUT,
+	PISTACHIO_EVT_SOURCE_PARALLEL_OUT,
+	PISTACHIO_EVT_NUM_SOURCES
+};
+
+#define	PISTACHIO_EVT_NUM_TIMESTAMP_MODULES	12
+
+#define	PISTACHIO_EVT_MAX_SOURCES		2
+
+extern struct pistachio_evt *pistachio_evt_get(struct device_node *np);
+
+extern void pistachio_evt_get_time_ts(struct pistachio_evt *evt,
+				struct timespec *ts);
+
+/* Call this outside of an event callback */
+extern void pistachio_evt_disable_event(struct pistachio_evt *evt,
+					enum pistachio_evt_enable event);
+
+/* Call this inside of an event callback */
+extern void _pistachio_evt_disable_event(struct pistachio_evt *evt,
+					enum pistachio_evt_enable event);
+
+extern int pistachio_evt_set_event(struct pistachio_evt *evt,
+	enum pistachio_evt_enable event, enum pistachio_evt_type type,
+	struct timespec *ts,
+	void (*event_trigger_callback)(struct pistachio_evt *, void *),
+	void *context);
+
+extern int pistachio_evt_set_source(struct pistachio_evt *evt, int id,
+				enum pistachio_evt_source source);
+
+extern int pistachio_evt_get_source(struct pistachio_evt *evt,
+			int id, enum pistachio_evt_source *source);
+
+extern int pistachio_evt_get_sample_rate(struct pistachio_evt *evt, int id,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *), void *context);
+
+extern int pistachio_evt_get_phase_difference(struct pistachio_evt *evt,
+			u32 *val, u32 *sys_freq,
+			void (*callback)(void *), void *context);
+
+extern void pistachio_evt_abort_measurements(struct pistachio_evt *evt);
+
+#endif
diff --git a/sound/soc/img/pistachio.c b/sound/soc/img/pistachio.c
new file mode 100644
index 0000000..9753a31
--- /dev/null
+++ b/sound/soc/img/pistachio.c
@@ -0,0 +1,2396 @@
+/*
+ * Pistachio audio card driver
+ *
+ * Copyright (C) 2015 Imagination Technologies Ltd.
+ *
+ * Author: Damien Horsley <Damien.Horsley@imgtec.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+
+#include <linux/mfd/syscon.h>
+
+#include <sound/jack.h>
+#include <sound/soc.h>
+
+#include <dt-bindings/sound/pistachio-audio.h>
+
+#include "pistachio-event-timer.h"
+
+#define	PISTACHIO_PLL_RATE_A		147456000
+#define	PISTACHIO_PLL_RATE_B		135475200
+#define	PISTACHIO_MAX_DIV		256
+#define	PISTACHIO_MIN_MCLK_FREQ		(135475200 / 256)
+
+#define	PISTACHIO_CLOCK_MASTER_EXT	-1
+#define	PISTACHIO_CLOCK_MASTER_LOOPBACK	-2
+
+#define	PISTACHIO_MAX_I2S_CODECS	12
+
+#define	PISTACHIO_MAX_FS_RATES	20
+
+#define	PISTACHIO_I2S_MCLK_MAX_FREQ	200000000
+#define	PISTACHIO_DAC_MCLK_MAX_FREQ	200000000
+
+#define	PISTACHIO_INTERNAL_DAC_PREFIX	"internal-dac"
+
+#define PISTACHIO_I2S_LOOPBACK_REG		0x88
+#define PISTACHIO_I2S_LOOPBACK_CLK_MASK		0x3
+#define PISTACHIO_I2S_LOOPBACK_CLK_SHIFT	0
+
+#define PISTACHIO_I2S_LOOPBACK_CLK_NONE		0
+#define PISTACHIO_I2S_LOOPBACK_CLK_MFIO		1
+#define PISTACHIO_I2S_LOOPBACK_CLK_LOCAL	2
+
+struct pistachio_start_at {
+	enum pistachio_evt_enable enable;
+	spinlock_t lock;
+	struct snd_pcm_substream *substream;
+	unsigned int dummy_frames;
+};
+
+struct pistachio_output {
+	struct pistachio_start_at start_at;
+	unsigned int active_rate;
+};
+
+struct pistachio_parallel_out {
+	struct pistachio_output output;
+	struct snd_soc_dai_link_component internal_dac;
+};
+
+struct pistachio_mclk {
+	struct clk *mclk;
+	unsigned int cur_rate;
+	unsigned int min_rate;
+	unsigned int max_rate;
+};
+
+struct pistachio_i2s_mclk {
+	struct pistachio_mclk *mclk;
+	unsigned int *fs_rates;
+	unsigned int num_fs_rates;
+};
+
+struct pistachio_codec_i2s {
+	struct pistachio_mclk *mclk;
+	struct snd_soc_dai *dai;
+	unsigned int mclk_index;
+};
+
+struct pistachio_i2s {
+	struct pistachio_i2s_mclk mclk_a;
+	struct pistachio_i2s_mclk mclk_b;
+	struct pistachio_codec_i2s *codecs;
+	struct snd_soc_dai_link_component *components;
+	unsigned int num_codecs;
+};
+
+struct pistachio_i2s_out {
+	struct pistachio_i2s i2s;
+	struct pistachio_output output;
+	struct device *cpu_dev;
+};
+
+struct pistachio_i2s_in {
+	struct pistachio_i2s i2s;
+	unsigned int active_rate;
+	unsigned int fmt;
+	int frame_master;
+	int bitclock_master;
+	struct device *cpu_dev;
+};
+
+struct pistachio_i2s_codec_info_s {
+	const char *prefix;
+	const char *dai_name;
+	struct device_node *np;
+	struct pistachio_mclk *mclk;
+	unsigned int mclk_index;
+};
+
+struct pistachio_i2s_codec_info {
+	unsigned int total_codecs;
+	unsigned int unique_codecs;
+	int bitclock_master_idx;
+	int frame_master_idx;
+	struct pistachio_i2s_codec_info_s codecs[PISTACHIO_MAX_I2S_CODECS];
+};
+
+struct pistachio_i2s_mclk_fs_info {
+	unsigned int fs_rates[PISTACHIO_MAX_FS_RATES];
+	unsigned int num_fs_rates;
+};
+
+struct pistachio_card {
+	struct pistachio_output *spdif_out;
+	struct pistachio_parallel_out *parallel_out;
+	struct pistachio_i2s_out *i2s_out;
+	struct pistachio_i2s_in *i2s_in;
+	bool spdif_in;
+	struct device_node *event_timer_np;
+	struct pistachio_evt *event_timer;
+	struct snd_soc_card card;
+	struct snd_soc_jack hp_jack;
+	struct snd_soc_jack_pin hp_jack_pin;
+	struct snd_soc_jack_gpio hp_jack_gpio;
+	unsigned int mute_gpio;
+	bool mute_gpio_inverted;
+	struct mutex rate_mutex;
+	struct clk *audio_pll;
+	unsigned int audio_pll_rate;
+	struct pistachio_mclk i2s_mclk;
+	struct pistachio_mclk dac_mclk;
+	struct regmap *periph_regs;
+	struct notifier_block i2s_clk_notifier;
+	struct snd_ctl_elem_id *sample_rate_ids[PISTACHIO_EVT_MAX_SOURCES];
+	struct snd_ctl_elem_id *phase_difference_id;
+};
+
+static void pistachio_card_set_mclk_codecs(struct pistachio_i2s *i2s,
+			struct pistachio_mclk *mclk, unsigned int rate)
+{
+	int i;
+	struct pistachio_codec_i2s *codec;
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		codec = &i2s->codecs[i];
+		if (codec->mclk == mclk) {
+			snd_soc_dai_set_sysclk(codec->dai, codec->mclk_index,
+						rate, SND_SOC_CLOCK_IN);
+		}
+	}
+}
+
+static int pistachio_card_set_mclk(struct pistachio_card *pbc,
+		struct pistachio_mclk *mclk, unsigned int rate)
+{
+	int ret;
+	unsigned int old_rate = mclk->cur_rate;
+
+	if (mclk->cur_rate != rate) {
+		/*
+		 * Set cur_rate before the clk_set_rate call to stop the i2s
+		 * mclk rate change callback rejecting the change
+		 */
+		mclk->cur_rate = rate;
+		ret = clk_set_rate(mclk->mclk, rate);
+		if (ret) {
+			mclk->cur_rate = old_rate;
+			return ret;
+		}
+	}
+
+	if (pbc->i2s_out)
+		pistachio_card_set_mclk_codecs(&pbc->i2s_out->i2s, mclk, rate);
+
+	if (pbc->i2s_in)
+		pistachio_card_set_mclk_codecs(&pbc->i2s_in->i2s, mclk, rate);
+
+	return 0;
+}
+
+static int pistachio_card_set_pll_rate(struct pistachio_card *pbc,
+					unsigned int rate)
+{
+	int ret;
+	unsigned int old_i2s_rate;
+
+	/*
+	 * If any active streams are currently using a clock derived
+	 * from the audio pll, a pll rate change cannot take place
+	 */
+	if ((pbc->spdif_out && pbc->spdif_out->active_rate) ||
+	(pbc->parallel_out && pbc->parallel_out->output.active_rate) ||
+	(pbc->i2s_out && pbc->i2s_out->output.active_rate) ||
+	(pbc->i2s_in && pbc->i2s_in->active_rate &&
+	pbc->i2s_in->i2s.mclk_a.mclk))
+		return -EBUSY;
+
+	/*
+	 * Set cur_rate before the clk_set_rate call to stop the i2s
+	 * mclk rate change callback rejecting the change
+	 */
+	old_i2s_rate = pbc->i2s_mclk.cur_rate;
+	pbc->i2s_mclk.cur_rate = rate / (pbc->audio_pll_rate / old_i2s_rate);
+
+	ret = clk_set_rate(pbc->audio_pll, rate);
+
+	if (ret) {
+		pbc->i2s_mclk.cur_rate = old_i2s_rate;
+	} else {
+		pbc->audio_pll_rate = rate;
+		pbc->dac_mclk.cur_rate = rate / (pbc->audio_pll_rate /
+						 pbc->dac_mclk.cur_rate);
+		pistachio_card_set_mclk(pbc, &pbc->i2s_mclk,
+				pbc->i2s_mclk.cur_rate);
+		pistachio_card_set_mclk(pbc, &pbc->dac_mclk,
+				pbc->dac_mclk.cur_rate);
+	}
+
+	return ret;
+}
+
+static void pistachio_card_rate_err(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b)
+{
+	char *mclk_name, *dir_a, *dir_b;
+
+	if (mclk_a->mclk == &pbc->i2s_mclk)
+		mclk_name = "i2s";
+	else
+		mclk_name = "dac";
+
+	if (pbc->i2s_out && ((mclk_a == &pbc->i2s_out->i2s.mclk_a) ||
+			(mclk_a == &pbc->i2s_out->i2s.mclk_b))) {
+		dir_a = "I2S out";
+		dir_b = "I2S in";
+	} else {
+		dir_a = "I2S in";
+		dir_b = "I2S out";
+	}
+
+	if (!mclk_b) {
+		dev_err(pbc->card.dev,
+			"No valid rate for mclk %s (%s sample rate %u)\n",
+			mclk_name, dir_a, rate_a);
+	} else {
+		dev_err(pbc->card.dev,
+			"No valid rate for mclk %s (%s sample rate %u, %s sample rate %u)\n",
+			mclk_name, dir_a, rate_a, dir_b, rate_b);
+	}
+}
+
+static int pistachio_card_get_optimal_mclk_rate(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b, unsigned int *p_mclk_rate)
+{
+	int i, j;
+	unsigned int div, total_div, mclk_rate;
+
+	/*
+	 * If the current system clock rate has zero difference, do not
+	 * change the rate. This ensures a rate set using the "I2S Rates"
+	 * control will not be erroneously overridden by a hw_params call
+	 */
+	for (i = 0; i < mclk_a->num_fs_rates; i++)
+		if ((mclk_a->mclk->cur_rate / mclk_a->fs_rates[i]) == rate_a)
+			break;
+	if (i != mclk_a->num_fs_rates) {
+		if (mclk_b) {
+			for (i = 0; i < mclk_b->num_fs_rates; i++)
+				if ((mclk_b->mclk->cur_rate /
+						mclk_b->fs_rates[i]) == rate_b)
+					break;
+			if (i != mclk_b->num_fs_rates) {
+				*p_mclk_rate = mclk_a->mclk->cur_rate;
+				return 0;
+			}
+		} else {
+			*p_mclk_rate = mclk_a->mclk->cur_rate;
+			return 0;
+		}
+	}
+
+	total_div = pbc->audio_pll_rate / rate_a;
+
+	for (i = 0; i < mclk_a->num_fs_rates; i++) {
+		div = total_div / mclk_a->fs_rates[i];
+		if (div > PISTACHIO_MAX_DIV)
+			continue;
+		mclk_rate = pbc->audio_pll_rate / div;
+		if ((mclk_rate < mclk_a->mclk->min_rate) ||
+				(mclk_rate > mclk_a->mclk->max_rate))
+			continue;
+		if ((rate_a * mclk_a->fs_rates[i] * div) != pbc->audio_pll_rate)
+			continue;
+
+		if (!mclk_b)
+			break;
+
+		for (j = 0; j < mclk_b->num_fs_rates; j++) {
+			if ((rate_b * mclk_b->fs_rates[j] * div) ==
+					pbc->audio_pll_rate)
+				break;
+		}
+		if (j != mclk_b->num_fs_rates)
+			break;
+	}
+
+	if (i == mclk_a->num_fs_rates) {
+		pistachio_card_rate_err(pbc, mclk_a, mclk_b, rate_a, rate_b);
+		return -EINVAL;
+	}
+
+	*p_mclk_rate = mclk_rate;
+
+	return 0;
+}
+
+static bool pistachio_card_mclk_active(struct pistachio_card *pbc,
+					struct pistachio_mclk *mclk)
+{
+	if (pbc->i2s_out && pbc->i2s_out->output.active_rate) {
+		if (pbc->i2s_out->i2s.mclk_a.mclk == mclk)
+			return true;
+		if (pbc->i2s_out->i2s.mclk_b.mclk == mclk)
+			return true;
+	}
+
+	if (pbc->i2s_in && pbc->i2s_in->active_rate) {
+		if (pbc->i2s_in->i2s.mclk_a.mclk == mclk)
+			return true;
+		if (pbc->i2s_in->i2s.mclk_b.mclk == mclk)
+			return true;
+	}
+
+	return false;
+}
+
+static int pistachio_card_update_mclk(struct pistachio_card *pbc,
+	struct pistachio_i2s_mclk *mclk_a, struct pistachio_i2s_mclk *mclk_b,
+	unsigned int rate_a, unsigned int rate_b)
+{
+	unsigned int mclk_rate;
+	int ret;
+
+	ret = pistachio_card_get_optimal_mclk_rate(pbc, mclk_a, mclk_b, rate_a,
+							rate_b, &mclk_rate);
+	if (ret)
+		return ret;
+
+	if (mclk_a->mclk->cur_rate != mclk_rate) {
+		if (pistachio_card_mclk_active(pbc, mclk_a->mclk))
+			return -EBUSY;
+		return pistachio_card_set_mclk(pbc, mclk_a->mclk, mclk_rate);
+	}
+
+	return 0;
+}
+
+static int pistachio_card_update_mclk_single(struct pistachio_card *pbc,
+		struct pistachio_i2s_mclk *mclk, unsigned int rate)
+{
+	return pistachio_card_update_mclk(pbc, mclk, NULL, rate, 0);
+}
+
+static inline int pistachio_card_get_pll_rate(unsigned int rate)
+{
+	switch (rate) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+	case 64000:
+	case 96000:
+	case 192000:
+		return PISTACHIO_PLL_RATE_A;
+	case 11025:
+	case 22050:
+	case 44100:
+	case 88200:
+	case 176400:
+		return PISTACHIO_PLL_RATE_B;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int _pistachio_card_change_rate(struct pistachio_card *pbc,
+			unsigned int rate, struct pistachio_i2s *i2s)
+{
+	int ret = 0;
+	unsigned int pll_rate;
+
+	ret = pistachio_card_get_pll_rate(rate);
+	if (ret < 0)
+		return ret;
+
+	pll_rate = ret;
+
+	if (pbc->audio_pll_rate != pll_rate) {
+		ret = pistachio_card_set_pll_rate(pbc, pll_rate);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * Nothing more to do if an mclk is not used. The individual
+	 * cpu-dai drivers will make the required clock changes
+	 */
+	if (!i2s)
+		return 0;
+
+	ret = pistachio_card_update_mclk_single(pbc, &i2s->mclk_a, rate);
+	if (ret)
+		return ret;
+
+	if (!i2s->mclk_b.mclk)
+		return 0;
+
+	return pistachio_card_update_mclk_single(pbc, &i2s->mclk_b, rate);
+}
+
+static int pistachio_card_change_rate(struct pistachio_card *pbc,
+			unsigned int rate, struct pistachio_i2s *i2s,
+			unsigned int *active_rate)
+{
+	int ret;
+
+	mutex_lock(&pbc->rate_mutex);
+	*active_rate = 0;
+	ret = _pistachio_card_change_rate(pbc, rate, i2s);
+	if (!ret)
+		*active_rate = rate;
+	mutex_unlock(&pbc->rate_mutex);
+
+	return ret;
+}
+
+static void pistachio_card_start_at_cb(struct pistachio_evt *evt,
+					void *context)
+{
+	struct pistachio_start_at *sa = context;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sa->lock, flags);
+
+	if (!sa->substream) {
+		spin_unlock_irqrestore(&sa->lock, flags);
+		return;
+	}
+
+	snd_pcm_start_at_trigger(sa->substream);
+
+	_pistachio_evt_disable_event(evt, sa->enable);
+
+	sa->substream = NULL;
+
+	spin_unlock_irqrestore(&sa->lock, flags);
+}
+
+static int pistachio_card_start_at(struct pistachio_output *output,
+		struct pistachio_evt *evt, struct snd_pcm_substream *st,
+		const struct timespec *ts)
+{
+	int ret;
+	unsigned long flags;
+	struct timespec ts_sub, ts_new;
+	struct pistachio_start_at *sa = &output->start_at;
+	u64 temp;
+
+	/* Adjust start time to account for dummy frames output at start */
+	temp = (u64)NSEC_PER_SEC * sa->dummy_frames;
+	ts_sub.tv_sec = 0;
+	ts_sub.tv_nsec = DIV_ROUND_CLOSEST_ULL(temp, output->active_rate);
+	ts_new = timespec_sub(*ts, ts_sub);
+
+	spin_lock_irqsave(&sa->lock, flags);
+
+	ret = pistachio_evt_set_event(evt, sa->enable,
+		PISTACHIO_EVT_TYPE_LEVEL, &ts_new,
+		pistachio_card_start_at_cb, sa);
+	if (!ret)
+		sa->substream = st;
+
+	spin_unlock_irqrestore(&sa->lock, flags);
+
+	return ret;
+}
+
+static int pistachio_card_start_at_abort(struct pistachio_start_at *sa,
+		struct pistachio_evt *evt, struct snd_pcm_substream *st)
+{
+	unsigned long flags;
+
+	if (spin_trylock_irqsave(&sa->lock, flags)) {
+		if (!sa->substream) {
+			/* Already started */
+			spin_unlock_irqrestore(&sa->lock, flags);
+			return -EINVAL;
+		}
+
+		snd_pcm_start_at_cleanup(st);
+
+		sa->substream = NULL;
+
+		spin_unlock_irqrestore(&sa->lock, flags);
+
+		pistachio_evt_disable_event(evt, sa->enable);
+	} else {
+		/* In the process of being started */
+		spin_unlock_irqrestore(&sa->lock, flags);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pistachio_card_i2s_link_init(struct pistachio_i2s *i2s,
+					struct snd_soc_pcm_runtime *rtd)
+{
+	int ret, i, id;
+	unsigned long rate;
+	struct pistachio_codec_i2s *codec;
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		codec = &i2s->codecs[i];
+		codec->dai = rtd->codec_dais[i];
+		if (codec->mclk) {
+			rate = codec->mclk->cur_rate;
+			id = codec->mclk_index;
+			ret = snd_soc_dai_set_sysclk(codec->dai, id, rate, 0);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void pistachio_card_parallel_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->parallel_out->output.active_rate = 0;
+}
+
+static int pistachio_card_parallel_out_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params), NULL,
+				&pbc->parallel_out->output.active_rate);
+}
+
+static int pistachio_card_parallel_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(&pbc->parallel_out->output,
+					pbc->event_timer, st, ts);
+}
+
+static int pistachio_card_parallel_out_start_at_abort(
+			struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at_abort(
+					&pbc->parallel_out->output.start_at,
+					pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_parallel_out_ops = {
+	.shutdown = pistachio_card_parallel_out_shutdown,
+	.hw_params = pistachio_card_parallel_out_hw_params,
+	.start_at = pistachio_card_parallel_out_start_at,
+	.start_at_abort = pistachio_card_parallel_out_start_at_abort
+};
+
+static void pistachio_card_spdif_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->spdif_out->active_rate = 0;
+}
+
+static int pistachio_card_spdif_out_hw_params(struct snd_pcm_substream *st,
+					struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params), NULL,
+					&pbc->spdif_out->active_rate);
+}
+
+static int pistachio_card_spdif_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(pbc->spdif_out, pbc->event_timer,
+					st, ts);
+}
+
+static int pistachio_card_spdif_out_start_at_abort(
+		struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at_abort(&pbc->spdif_out->start_at,
+						pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_spdif_out_ops = {
+	.shutdown = pistachio_card_spdif_out_shutdown,
+	.hw_params = pistachio_card_spdif_out_hw_params,
+	.start_at = pistachio_card_spdif_out_start_at,
+	.start_at_abort = pistachio_card_spdif_out_start_at_abort
+};
+
+static int pistachio_card_i2s_clk_cb(struct notifier_block *nb,
+					unsigned long event, void *data)
+{
+	struct clk_notifier_data *ndata = data;
+	struct pistachio_card *pbc;
+	unsigned int diff;
+	u64 cur_rate;
+	u64 tolerance;
+
+	pbc = container_of(nb, struct pistachio_card, i2s_clk_notifier);
+
+	cur_rate = pbc->i2s_mclk.cur_rate;
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		diff = abs(ndata->new_rate - cur_rate);
+		tolerance = DIV_ROUND_CLOSEST_ULL(cur_rate * 5, 100);
+		if (diff < tolerance) {
+			/*
+			 * Fractional adjustment made by atu, or new rate set
+			 * by card driver if diff is zero
+			 */
+			return NOTIFY_OK;
+		} else {
+			/* Significant change made by i2s cpu dai driver */
+			return NOTIFY_STOP;
+		}
+	case POST_RATE_CHANGE:
+	case ABORT_RATE_CHANGE:
+		return NOTIFY_OK;
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+static int pistachio_card_i2s_out_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_out->cpu_dev = rtd->cpu_dai->dev;
+
+	return pistachio_card_i2s_link_init(&pbc->i2s_out->i2s, rtd);
+}
+
+static void pistachio_card_i2s_out_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_out->output.active_rate = 0;
+}
+
+static int pistachio_card_i2s_out_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params),
+		&pbc->i2s_out->i2s, &pbc->i2s_out->output.active_rate);
+}
+
+static int pistachio_card_i2s_out_start_at(struct snd_pcm_substream *st,
+		int clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at(&pbc->i2s_out->output,
+					pbc->event_timer, st, ts);
+}
+
+static int pistachio_card_i2s_out_start_at_abort(
+		struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_start_at_abort(&pbc->i2s_out->output.start_at,
+						pbc->event_timer, st);
+}
+
+static struct snd_soc_ops pistachio_card_i2s_out_ops = {
+	.shutdown = pistachio_card_i2s_out_shutdown,
+	.hw_params = pistachio_card_i2s_out_hw_params,
+	.start_at = pistachio_card_i2s_out_start_at,
+	.start_at_abort = pistachio_card_i2s_out_start_at_abort
+};
+
+static int pistachio_card_i2s_in_link_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret, i;
+	unsigned int fmt;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+	u32 val;
+
+	pbc->i2s_in->cpu_dev = rtd->cpu_dai->dev;
+
+	ret = pistachio_card_i2s_link_init(&pbc->i2s_in->i2s, rtd);
+	if (ret)
+		return ret;
+
+	fmt = pbc->i2s_in->fmt | SND_SOC_DAIFMT_CBM_CFM;
+	ret = snd_soc_dai_set_fmt(rtd->cpu_dai, fmt);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < pbc->i2s_in->i2s.num_codecs; i++) {
+		fmt = pbc->i2s_in->fmt;
+
+		if (i == pbc->i2s_in->frame_master)
+			if (i == pbc->i2s_in->bitclock_master)
+				fmt |= SND_SOC_DAIFMT_CBM_CFM;
+			else
+				fmt |= SND_SOC_DAIFMT_CBS_CFM;
+		else
+			if (i == pbc->i2s_in->bitclock_master)
+				fmt |= SND_SOC_DAIFMT_CBM_CFS;
+			else
+				fmt |= SND_SOC_DAIFMT_CBS_CFS;
+
+		ret = snd_soc_dai_set_fmt(rtd->codec_dais[i], fmt);
+		if (ret)
+			return ret;
+	}
+
+	if (pbc->i2s_in->frame_master == PISTACHIO_CLOCK_MASTER_LOOPBACK)
+		val = PISTACHIO_I2S_LOOPBACK_CLK_LOCAL;
+	else
+		val = PISTACHIO_I2S_LOOPBACK_CLK_NONE;
+
+	regmap_update_bits(pbc->periph_regs, PISTACHIO_I2S_LOOPBACK_REG,
+				PISTACHIO_I2S_LOOPBACK_CLK_MASK, val);
+
+	return 0;
+}
+
+static void pistachio_card_i2s_in_shutdown(struct snd_pcm_substream *st)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	pbc->i2s_in->active_rate = 0;
+}
+
+static int pistachio_card_i2s_in_hw_params(struct snd_pcm_substream *st,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = st->private_data;
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(rtd->card);
+
+	return pistachio_card_change_rate(pbc, params_rate(params),
+		&pbc->i2s_in->i2s, &pbc->i2s_in->active_rate);
+}
+
+static struct snd_soc_ops pistachio_card_i2s_in_ops = {
+	.shutdown = pistachio_card_i2s_in_shutdown,
+	.hw_params = pistachio_card_i2s_in_hw_params
+};
+
+static int pistachio_card_parse_of_spdif_out(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
+{
+	struct device_node *np;
+
+	pbc->spdif_out = devm_kzalloc(pbc->card.dev, sizeof(*pbc->spdif_out),
+					GFP_KERNEL);
+	if (!pbc->spdif_out)
+		return -ENOMEM;
+
+	pbc->spdif_out->start_at.enable = PISTACHIO_EVT_ENABLE_SPDIF_OUT;
+	pbc->spdif_out->start_at.dummy_frames = 1;
+	spin_lock_init(&pbc->spdif_out->start_at.lock);
+
+	link->name = link->stream_name = "pistachio-spdif-out";
+
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
+
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codec_dai_name = "snd-soc-dummy-dai";
+	link->codec_name = "snd-soc-dummy";
+	link->ops = &pistachio_card_spdif_out_ops;
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_spdif_in(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
+{
+	struct device_node *np;
+
+	pbc->spdif_in = true;
+
+	link->name = link->stream_name = "pistachio-spdif-in";
+
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
+
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codec_dai_name = "snd-soc-dummy-dai";
+	link->codec_name = "snd-soc-dummy";
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_parallel_out(struct device_node *node,
+		struct pistachio_card *pbc, struct snd_soc_dai_link *link)
+{
+	struct device_node *np;
+	int ret;
+
+	pbc->parallel_out = devm_kzalloc(pbc->card.dev,
+			sizeof(*pbc->parallel_out), GFP_KERNEL);
+	if (!pbc->parallel_out)
+		return -ENOMEM;
+
+	pbc->parallel_out->output.start_at.enable =
+			PISTACHIO_EVT_ENABLE_PARALLEL_OUT;
+	pbc->parallel_out->output.start_at.dummy_frames = 2;
+	spin_lock_init(&pbc->parallel_out->output.start_at.lock);
+
+	link->name = link->stream_name = "pistachio-parallel-out";
+
+	np = of_parse_phandle(node, "cpu-dai", 0);
+	if (!np)
+		return -EINVAL;
+
+	link->cpu_of_node = np;
+	link->platform_of_node = np;
+	link->codecs = &pbc->parallel_out->internal_dac;
+	np = of_parse_phandle(node, "sound-dai", 0);
+	if (!np)
+		return -EINVAL;
+	link->codecs[0].of_node = np;
+	link->num_codecs = 1;
+	ret = snd_soc_of_get_dai_name(node, &link->codecs[0].dai_name);
+	if (ret)
+		return ret;
+
+	link->ops = &pistachio_card_parallel_out_ops;
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_i2s_mclk(struct device_node *np,
+	struct pistachio_mclk *mclk, struct pistachio_i2s_mclk_fs_info *fs)
+{
+	int ret, i, j, k, num_fs_rates;
+	u32 min_freq, max_freq, fs_rates[PISTACHIO_MAX_FS_RATES];
+
+	ret = of_property_read_u32(np, "mclk-min-freq", &min_freq);
+	if (ret)
+		return ret;
+	ret = of_property_read_u32(np, "mclk-max-freq", &max_freq);
+	if (ret)
+		return ret;
+
+	if (max_freq < PISTACHIO_MIN_MCLK_FREQ)
+		return -EINVAL;
+	if (min_freq > mclk->min_rate)
+		mclk->min_rate = min_freq;
+	if (max_freq < mclk->max_rate)
+		mclk->max_rate = max_freq;
+	if (mclk->min_rate > mclk->max_rate)
+		return -EINVAL;
+
+	num_fs_rates = of_property_count_u32_elems(np, "mclk-fs");
+	if (num_fs_rates < 0)
+		return num_fs_rates;
+	if (!num_fs_rates || (num_fs_rates > PISTACHIO_MAX_FS_RATES))
+		return -EINVAL;
+
+	ret = of_property_read_u32_array(np, "mclk-fs", fs_rates,
+						num_fs_rates);
+	if (ret)
+		return ret;
+
+	/*
+	 * If this is the first fs-rates list for this combination
+	 * of {i2s direction, mclk}, this list defines the
+	 * current fs-rate list for this combination. Else, this list
+	 * subtracts any fs-rates that are not present in both lists from the
+	 * current list for this combination
+	 */
+	if (!fs->num_fs_rates) {
+		for (i = 0; i < num_fs_rates; i++)
+			fs->fs_rates[i] = fs_rates[i];
+		fs->num_fs_rates = num_fs_rates;
+	} else {
+		for (j = 0; j < fs->num_fs_rates; j++) {
+			for (i = 0; i < num_fs_rates; i++)
+				if (fs->fs_rates[j] == fs_rates[i])
+					break;
+			if (i == num_fs_rates) {
+				for (k = j; k < (fs->num_fs_rates - 1); k++)
+					fs->fs_rates[k] = fs->fs_rates[k + 1];
+				fs->num_fs_rates--;
+				if (!fs->num_fs_rates)
+					return -EINVAL;
+				j--;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_i2s_codecs(struct device_node *np,
+			struct pistachio_card *pbc,
+			struct pistachio_i2s_codec_info *codec_info,
+			struct pistachio_i2s_mclk_fs_info *i2s_fs_info,
+			struct pistachio_i2s_mclk_fs_info *dac_fs_info)
+{
+	int i, j, ret;
+	struct device_node *subnode, *codec;
+	struct pistachio_i2s_codec_info_s *info;
+	u32 mclk_id;
+	struct pistachio_mclk *mclk;
+	struct pistachio_i2s_mclk_fs_info *fs_info;
+
+	j = 0;
+	for_each_child_of_node(np, subnode) {
+		ret = of_property_read_u32(subnode, "mclk", &mclk_id);
+		if (ret)
+			return ret;
+
+		switch (mclk_id) {
+		case PISTACHIO_MCLK_I2S:
+			mclk = &pbc->i2s_mclk;
+			fs_info = i2s_fs_info;
+			break;
+		case PISTACHIO_MCLK_DAC:
+			mclk = &pbc->dac_mclk;
+			fs_info = dac_fs_info;
+			break;
+		case PISTACHIO_MCLK_NONE:
+			mclk = NULL;
+			break;
+		default:
+			ret = -EINVAL;
+			goto err_subnode;
+		}
+		if (mclk) {
+			ret = pistachio_card_parse_of_i2s_mclk(subnode, mclk,
+								fs_info);
+			if (ret)
+				goto err_subnode;
+		}
+
+		codec = of_parse_phandle(subnode, "sound-dai", 0);
+		if (!codec)
+			continue;
+		if (codec_info->total_codecs == PISTACHIO_MAX_I2S_CODECS) {
+			ret = -EINVAL;
+			of_node_put(codec);
+			goto err_subnode;
+		}
+		for (i = 0; i < codec_info->total_codecs; i++)
+			if (codec_info->codecs[i].np == codec)
+				break;
+		if (i == codec_info->total_codecs)
+			codec_info->unique_codecs++;
+		info = &codec_info->codecs[codec_info->total_codecs++];
+		info->np = codec;
+		info->prefix = subnode->name;
+		ret = snd_soc_of_get_dai_name(subnode, &info->dai_name);
+		if (ret)
+			goto err_subnode;
+		info->mclk = mclk;
+		ret = of_property_read_u32(subnode, "mclk-index",
+						&info->mclk_index);
+		if (ret)
+			info->mclk_index = 0;
+		if (of_property_read_bool(subnode, "frame-master")) {
+			if (codec_info->frame_master_idx != -1) {
+				ret = -EINVAL;
+				goto err_subnode;
+			}
+			codec_info->frame_master_idx = j;
+		}
+		if (of_property_read_bool(subnode, "bitclock-master")) {
+			if (codec_info->bitclock_master_idx != -1) {
+				ret = -EINVAL;
+				goto err_subnode;
+			}
+			codec_info->bitclock_master_idx = j;
+		}
+		j++;
+	}
+
+	return 0;
+
+err_subnode:
+	of_node_put(subnode);
+	return ret;
+}
+
+static int pistachio_card_parse_of_i2s_common(struct device_node *node,
+	struct pistachio_card *pbc, struct pistachio_i2s *i2s,
+	struct snd_soc_dai_link *link,
+	struct pistachio_i2s_codec_info *codec_info,
+	struct pistachio_i2s_mclk_fs_info *i2s_mclk_info,
+	struct pistachio_i2s_mclk_fs_info *dac_mclk_info)
+{
+	int ret, i;
+	unsigned int initial_codecs = codec_info->total_codecs, size;
+	struct pistachio_i2s_codec_info_s *codecs;
+	struct pistachio_i2s_mclk *mclk;
+
+	codecs = &codec_info->codecs[initial_codecs];
+
+	ret = pistachio_card_parse_of_i2s_codecs(node, pbc, codec_info,
+					i2s_mclk_info, dac_mclk_info);
+	i2s->num_codecs = codec_info->total_codecs - initial_codecs;
+	if (ret)
+		goto err_codec_info;
+
+	mclk = &i2s->mclk_a;
+
+	if (i2s_mclk_info->num_fs_rates) {
+		mclk->mclk = &pbc->i2s_mclk;
+		mclk->num_fs_rates = i2s_mclk_info->num_fs_rates;
+		size = sizeof(*mclk->fs_rates) * mclk->num_fs_rates;
+		mclk->fs_rates = devm_kzalloc(pbc->card.dev, size,
+							GFP_KERNEL);
+		if (!mclk->fs_rates) {
+			ret = -ENOMEM;
+			goto err_codec_info;
+		}
+		memcpy(mclk->fs_rates, i2s_mclk_info->fs_rates, size);
+		mclk = &i2s->mclk_b;
+	}
+
+	if (dac_mclk_info->num_fs_rates) {
+		mclk->mclk = &pbc->dac_mclk;
+		mclk->num_fs_rates = dac_mclk_info->num_fs_rates;
+		size = sizeof(*mclk->fs_rates) * mclk->num_fs_rates;
+		mclk->fs_rates = devm_kzalloc(pbc->card.dev, size,
+							GFP_KERNEL);
+		if (!mclk->fs_rates) {
+			ret = -ENOMEM;
+			goto err_codec_info;
+		}
+		memcpy(mclk->fs_rates, dac_mclk_info->fs_rates, size);
+	}
+
+	if (!i2s->num_codecs) {
+		link->codec_dai_name = "snd-soc-dummy-dai";
+		link->codec_name = "snd-soc-dummy";
+		return 0;
+	}
+
+	i2s->codecs = devm_kzalloc(pbc->card.dev,
+		sizeof(*i2s->codecs) * i2s->num_codecs, GFP_KERNEL);
+	if (!i2s->codecs) {
+		ret = -ENOMEM;
+		goto err_codec_info;
+	}
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		i2s->codecs[i].mclk = codecs[i].mclk;
+		i2s->codecs[i].mclk_index = codecs[i].mclk_index;
+	}
+
+	i2s->components = devm_kzalloc(pbc->card.dev,
+		sizeof(*i2s->components) * i2s->num_codecs, GFP_KERNEL);
+	if (!i2s->components) {
+		ret = -ENOMEM;
+		goto err_codec_info;
+	}
+
+	for (i = 0; i < i2s->num_codecs; i++) {
+		i2s->components[i].dai_name = codecs[i].dai_name;
+		i2s->components[i].of_node = codecs[i].np;
+	}
+
+	link->codecs = i2s->components;
+	link->num_codecs = i2s->num_codecs;
+
+	return 0;
+
+err_codec_info:
+	for (i = 0; i < i2s->num_codecs; i++)
+		of_node_put(codecs[i].np);
+
+	return ret;
+}
+
+static int pistachio_card_parse_of_i2s(struct device_node *i2s_out_np,
+	struct device_node *i2s_in_np, struct pistachio_card *pbc,
+	struct snd_soc_dai_link *links,
+	struct pistachio_i2s_codec_info *codec_info,
+	bool i2s_loopback)
+{
+	int ret;
+	struct device *dev = pbc->card.dev;
+	unsigned int fmt;
+	struct device_node *np;
+	struct pistachio_i2s_mclk_fs_info i2s_mclk_info, dac_mclk_info;
+
+	pbc->i2s_mclk.max_rate = PISTACHIO_I2S_MCLK_MAX_FREQ;
+	pbc->dac_mclk.max_rate = PISTACHIO_DAC_MCLK_MAX_FREQ;
+
+	codec_info->bitclock_master_idx = -1;
+	codec_info->frame_master_idx = -1;
+
+	if (i2s_out_np) {
+		pbc->i2s_out = devm_kzalloc(dev, sizeof(*pbc->i2s_out),
+						GFP_KERNEL);
+		if (!pbc->i2s_out)
+			return -ENOMEM;
+
+		pbc->i2s_out->output.start_at.enable =
+				PISTACHIO_EVT_ENABLE_I2S_OUT;
+		pbc->i2s_out->output.start_at.dummy_frames = 1;
+		spin_lock_init(&pbc->i2s_out->output.start_at.lock);
+
+		links->name = links->stream_name = "pistachio-i2s-out";
+
+		np = of_parse_phandle(i2s_out_np, "cpu-dai", 0);
+		if (!np)
+			return -EINVAL;
+
+		links->cpu_of_node = np;
+		links->platform_of_node = np;
+
+		fmt = snd_soc_of_parse_daifmt(i2s_out_np, NULL, NULL, NULL);
+		fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+		links->dai_fmt = fmt;
+
+		/*
+		 * Internal i2s out controller uses i2s_mclk and
+		 * accepts 256fs,384fs
+		 */
+		i2s_mclk_info.fs_rates[0] = 256;
+		i2s_mclk_info.fs_rates[1] = 384;
+		i2s_mclk_info.num_fs_rates = 2;
+		dac_mclk_info.num_fs_rates = 0;
+
+		ret = pistachio_card_parse_of_i2s_common(i2s_out_np, pbc,
+				&pbc->i2s_out->i2s, links, codec_info,
+				&i2s_mclk_info, &dac_mclk_info);
+		if (ret)
+			return ret;
+
+		links->init = pistachio_card_i2s_out_link_init;
+		links->ops = &pistachio_card_i2s_out_ops;
+
+		links++;
+	}
+
+	if (i2s_in_np) {
+		pbc->i2s_in = devm_kzalloc(dev, sizeof(*pbc->i2s_in),
+						GFP_KERNEL);
+		if (!pbc->i2s_in)
+			return -ENOMEM;
+
+		links->name = links->stream_name = "pistachio-i2s-in";
+
+		np = of_parse_phandle(i2s_in_np, "cpu-dai", 0);
+		if (!np)
+			return -EINVAL;
+
+		links->cpu_of_node = np;
+		links->platform_of_node = np;
+
+		fmt = snd_soc_of_parse_daifmt(i2s_in_np, NULL, NULL, NULL);
+		fmt &= ~SND_SOC_DAIFMT_MASTER_MASK;
+		pbc->i2s_in->fmt = fmt;
+
+		i2s_mclk_info.num_fs_rates = 0;
+		dac_mclk_info.num_fs_rates = 0;
+
+		ret = pistachio_card_parse_of_i2s_common(i2s_in_np, pbc,
+				&pbc->i2s_in->i2s, links, codec_info,
+				&i2s_mclk_info, &dac_mclk_info);
+		if (ret)
+			return ret;
+
+		if (i2s_loopback) {
+			pbc->i2s_in->frame_master =
+					PISTACHIO_CLOCK_MASTER_LOOPBACK;
+			pbc->i2s_in->bitclock_master =
+					PISTACHIO_CLOCK_MASTER_LOOPBACK;
+		} else if ((codec_info->bitclock_master_idx == -1) ||
+				(codec_info->frame_master_idx == -1)) {
+			pbc->i2s_in->frame_master =
+					PISTACHIO_CLOCK_MASTER_EXT;
+			pbc->i2s_in->bitclock_master =
+					PISTACHIO_CLOCK_MASTER_EXT;
+		} else {
+			pbc->i2s_in->frame_master =
+					codec_info->frame_master_idx;
+			pbc->i2s_in->bitclock_master =
+					codec_info->bitclock_master_idx;
+		}
+
+		links->init = pistachio_card_i2s_in_link_init;
+
+		/*
+		 * If no mclks are used by i2s in, there is nothing for
+		 * the ops callbacks to do, so leave this as NULL
+		 */
+		if (pbc->i2s_in->i2s.mclk_a.mclk)
+			links->ops = &pistachio_card_i2s_in_ops;
+	}
+
+	return 0;
+}
+
+static int pistachio_card_parse_of_confs(struct pistachio_card *pbc,
+			struct pistachio_i2s_codec_info *codec_info,
+			struct snd_soc_dai_link *parallel_out)
+{
+	int i, j, n;
+	unsigned int size;
+	struct pistachio_i2s_codec_info_s *codecs;
+	struct snd_soc_codec_conf *conf, *c;
+
+	n = codec_info->unique_codecs;
+	if (parallel_out)
+		n++;
+	codecs = codec_info->codecs;
+
+	size = sizeof(*pbc->card.codec_conf) * n;
+	pbc->card.codec_conf = devm_kzalloc(pbc->card.dev, size, GFP_KERNEL);
+	if (!pbc->card.codec_conf)
+		return -ENOMEM;
+
+	conf = pbc->card.codec_conf;
+
+	for (i = 0; i < codec_info->total_codecs; i++) {
+		for (j = 0; j < i; j++)
+			if (codecs[j].np == codecs[i].np)
+				break;
+		if (j == i) {
+			conf->of_node = codecs[i].np;
+			conf->name_prefix = codecs[i].prefix;
+			conf++;
+		}
+	}
+
+	if (parallel_out) {
+		conf->of_node = parallel_out->codecs[0].of_node;
+		conf->name_prefix = PISTACHIO_INTERNAL_DAC_PREFIX;
+	}
+
+	pbc->card.num_configs = n;
+
+	for (i = 0; i < n; i++) {
+		conf = &pbc->card.codec_conf[i];
+		for (j = i + 1; j < n; j++) {
+			c = &pbc->card.codec_conf[j];
+			if (!strcasecmp(conf->name_prefix, c->name_prefix)) {
+				dev_err(pbc->card.dev, "Prefix clash: %s\n",
+						conf->name_prefix);
+				return -EINVAL;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int pistachio_card_parse_of(struct device_node *node,
+				struct pistachio_card *pbc)
+{
+	int ret = 0;
+	struct device_node *spdif_out_np, *spdif_in_np, *parallel_out_np;
+	struct device_node *i2s_out_np, *i2s_in_np, *event_np;
+	struct snd_soc_dai_link *link, *prl_out = NULL;
+	enum of_gpio_flags flags;
+	struct pistachio_i2s_codec_info i2s_codec_info;
+	bool i2s_loopback;
+
+	pbc->periph_regs = syscon_regmap_lookup_by_phandle(node,
+						"img,cr-periph");
+	if (IS_ERR(pbc->periph_regs))
+		return PTR_ERR(pbc->periph_regs);
+
+	event_np = of_parse_phandle(node, "img,event-timer", 0);
+	if (!event_np)
+		return -EINVAL;
+	pbc->event_timer_np = event_np;
+	pbc->event_timer = pistachio_evt_get(event_np);
+	if (IS_ERR(pbc->event_timer))
+		return PTR_ERR(pbc->event_timer);
+
+	if (of_property_read_bool(node, "img,widgets")) {
+		ret = snd_soc_of_parse_audio_simple_widgets(&pbc->card,
+					"img,widgets");
+		if (ret)
+			return ret;
+	}
+
+	if (of_property_read_bool(node, "img,routing")) {
+		ret = snd_soc_of_parse_audio_routing(&pbc->card,
+					"img,routing");
+		if (ret)
+			return ret;
+	}
+
+	spdif_out_np = of_get_child_by_name(node, "spdif-out");
+	if (spdif_out_np)
+		pbc->card.num_links++;
+
+	spdif_in_np = of_get_child_by_name(node, "spdif-in");
+	if (spdif_in_np)
+		pbc->card.num_links++;
+
+	parallel_out_np = of_get_child_by_name(node, "parallel-out");
+	if (parallel_out_np)
+		pbc->card.num_links++;
+
+	i2s_out_np = of_get_child_by_name(node, "i2s-out");
+	if (i2s_out_np)
+		pbc->card.num_links++;
+
+	i2s_in_np = of_get_child_by_name(node, "i2s-in");
+	if (i2s_in_np)
+		pbc->card.num_links++;
+
+	i2s_loopback = of_property_read_bool(node, "img,i2s-clk-loopback");
+	if (i2s_loopback && (!i2s_out_np || !i2s_in_np)) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	if (!pbc->card.num_links) {
+		ret = -EINVAL;
+		goto end;
+	}
+
+	pbc->card.dai_link = devm_kzalloc(pbc->card.dev,
+		sizeof(*pbc->card.dai_link) * pbc->card.num_links, GFP_KERNEL);
+	if (!pbc->card.dai_link) {
+		ret = -ENOMEM;
+		goto end;
+	}
+
+	i2s_codec_info.total_codecs = 0;
+	i2s_codec_info.unique_codecs = 0;
+
+	link = pbc->card.dai_link;
+
+	if (spdif_out_np) {
+		ret = pistachio_card_parse_of_spdif_out(spdif_out_np, pbc,
+							link);
+		if (ret)
+			goto end;
+		link++;
+	}
+
+	if (spdif_in_np) {
+		ret = pistachio_card_parse_of_spdif_in(spdif_in_np, pbc,
+							link);
+		if (ret)
+			goto end;
+		link++;
+	}
+
+	if (parallel_out_np) {
+		ret = pistachio_card_parse_of_parallel_out(parallel_out_np,
+								pbc, link);
+		if (ret)
+			goto end;
+		prl_out = link;
+		link++;
+	}
+
+	if (i2s_out_np || i2s_in_np) {
+		ret = pistachio_card_parse_of_i2s(i2s_out_np, i2s_in_np, pbc,
+					link, &i2s_codec_info, i2s_loopback);
+		if (ret)
+			goto end;
+	}
+
+	ret = pistachio_card_parse_of_confs(pbc, &i2s_codec_info, prl_out);
+	if (ret)
+		goto end;
+
+	pbc->hp_jack_gpio.gpio = of_get_named_gpio_flags(node,
+					"img,hp-det-gpio", 0, &flags);
+	pbc->hp_jack_gpio.invert = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (pbc->hp_jack_gpio.gpio == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+	pbc->mute_gpio = of_get_named_gpio_flags(node, "img,mute-gpio", 0,
+						&flags);
+	pbc->mute_gpio_inverted = !!(flags & OF_GPIO_ACTIVE_LOW);
+	if (pbc->mute_gpio_inverted == -EPROBE_DEFER) {
+		ret = -EPROBE_DEFER;
+		goto end;
+	}
+
+end:
+	if (spdif_out_np)
+		of_node_put(spdif_out_np);
+	if (spdif_in_np)
+		of_node_put(spdif_in_np);
+	if (parallel_out_np)
+		of_node_put(parallel_out_np);
+	if (i2s_out_np)
+		of_node_put(i2s_out_np);
+	if (i2s_in_np)
+		of_node_put(i2s_in_np);
+
+	return ret;
+}
+
+static void pistachio_card_unref(struct pistachio_card *pbc)
+{
+	int i, j;
+	struct snd_soc_dai_link *link;
+
+	if (pbc->event_timer_np)
+		of_node_put(pbc->event_timer_np);
+
+	link = pbc->card.dai_link;
+	if (!link)
+		return;
+
+	for (i = 0; i < pbc->card.num_links; i++, link++) {
+		if (link->cpu_of_node)
+			of_node_put(link->cpu_of_node);
+		for (j = 0; j < link->num_codecs; j++)
+			of_node_put(link->codecs[j].of_node);
+	}
+}
+
+static int pistachio_card_init_clk(struct device *dev, char *name,
+					struct clk **pclk)
+{
+	struct clk *clk;
+	int ret;
+
+	clk = devm_clk_get(dev, name);
+	if (IS_ERR(clk))
+		return PTR_ERR(clk);
+
+	ret = clk_prepare_enable(clk);
+	if (ret)
+		return ret;
+
+	*pclk = clk;
+
+	return 0;
+}
+
+static int pistachio_card_init_rates(struct pistachio_card *pbc)
+{
+	unsigned int rate;
+	int ret;
+
+	rate = PISTACHIO_PLL_RATE_B;
+	ret = clk_set_rate(pbc->audio_pll, rate);
+	if (ret)
+		return ret;
+	pbc->audio_pll_rate = rate;
+
+	rate = PISTACHIO_MIN_MCLK_FREQ;
+	ret = clk_set_rate(pbc->i2s_mclk.mclk, rate);
+	if (ret)
+		return ret;
+	pbc->i2s_mclk.cur_rate = rate;
+	ret = clk_set_rate(pbc->dac_mclk.mclk, rate);
+	if (ret)
+		return ret;
+	pbc->dac_mclk.cur_rate = rate;
+
+	return 0;
+}
+
+static int pistachio_card_info_timespec(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
+
+	return 0;
+}
+
+static int pistachio_card_get_event_time(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *uc)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	struct timespec ts;
+
+	pistachio_evt_get_time_ts(pbc->event_timer, &ts);
+
+	uc->value.integer.value[0] = ts.tv_sec;
+	uc->value.integer.value[1] = ts.tv_nsec;
+
+	return 0;
+}
+
+static int pistachio_card_info_source(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = PISTACHIO_EVT_NUM_SOURCES - 1;
+
+	return 0;
+}
+
+static int pistachio_card_set_source(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+
+	return pistachio_evt_set_source(pbc->event_timer, id,
+		ucontrol->value.integer.value[0]);
+}
+
+static int pistachio_card_set_source_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_set_source(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_set_source_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_set_source(kcontrol, ucontrol, 1);
+}
+
+static int pistachio_card_get_source(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	enum pistachio_evt_source source;
+	int ret;
+
+	ret = pistachio_evt_get_source(pbc->event_timer, id, &source);
+
+	if (!ret)
+		ucontrol->value.integer.value[0] = source;
+
+	return ret;
+}
+
+static int pistachio_card_get_source_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_source(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_get_source_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_source(kcontrol, ucontrol, 1);
+}
+
+void pistachio_card_sample_rate_notify(int id, void *context)
+{
+	struct pistachio_card *pbc = context;
+
+	if (pbc->sample_rate_ids[id])
+		snd_ctl_notify(pbc->card.snd_card, SNDRV_CTL_EVENT_MASK_VALUE,
+				pbc->sample_rate_ids[id]);
+}
+
+void pistachio_card_sample_rate_notify_a(void *context)
+{
+	pistachio_card_sample_rate_notify(0, context);
+}
+
+void pistachio_card_sample_rate_notify_b(void *context)
+{
+	pistachio_card_sample_rate_notify(1, context);
+}
+
+void pistachio_card_phase_difference_notify(void *context)
+{
+	struct pistachio_card *pbc = context;
+
+	if (pbc->phase_difference_id)
+		snd_ctl_notify(pbc->card.snd_card, SNDRV_CTL_EVENT_MASK_VALUE,
+				pbc->phase_difference_id);
+}
+
+static int pistachio_card_get_sample_period(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, nsec;
+	u64 temp;
+
+	pbc->sample_rate_ids[id] = &kcontrol->id;
+
+	ret = pistachio_evt_get_sample_rate(pbc->event_timer, id, &val, &freq,
+				pistachio_card_sample_rate_notify_a, pbc);
+
+	if (!ret) {
+		temp = ((u64)val * NSEC_PER_SEC) + (freq / 2);
+		do_div(temp, freq);
+		nsec = do_div(temp, NSEC_PER_SEC);
+		ucontrol->value.integer.value[0] = temp;
+		ucontrol->value.integer.value[1] = nsec;
+	}
+
+	return ret;
+}
+
+static int pistachio_card_get_sample_period_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_period(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_get_sample_period_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_period(kcontrol, ucontrol, 1);
+}
+
+static int pistachio_card_info_sample_rate(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = LONG_MAX;
+
+	return 0;
+}
+
+static int pistachio_card_get_sample_rate(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol,
+				  int id)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, rate;
+
+	pbc->sample_rate_ids[id] = &kcontrol->id;
+
+	ret = pistachio_evt_get_sample_rate(pbc->event_timer, id, &val, &freq,
+				pistachio_card_sample_rate_notify_b, pbc);
+
+	if (!ret) {
+		if (!val)
+			return -EINVAL;
+		rate = DIV_ROUND_CLOSEST(freq, val);
+		ucontrol->value.integer.value[0] = rate;
+	}
+
+	return ret;
+}
+
+static int pistachio_card_get_sample_rate_a(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_rate(kcontrol, ucontrol, 0);
+}
+
+static int pistachio_card_get_sample_rate_b(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	return pistachio_card_get_sample_rate(kcontrol, ucontrol, 1);
+}
+
+static int pistachio_card_get_phase_difference(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	u32 val, freq, nsec;
+	u64 temp;
+
+	pbc->phase_difference_id = &kcontrol->id;
+
+	ret = pistachio_evt_get_phase_difference(pbc->event_timer, &val,
+			&freq, pistachio_card_phase_difference_notify, pbc);
+
+	if (!ret) {
+		temp = ((u64)val * NSEC_PER_SEC) + (freq / 2);
+		do_div(temp, freq);
+		nsec = do_div(temp, NSEC_PER_SEC);
+		ucontrol->value.integer.value[0] = temp;
+		ucontrol->value.integer.value[1] = nsec;
+	}
+
+	return ret;
+}
+
+static int pistachio_card_get_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	ret = gpio_get_value_cansleep(pbc->mute_gpio);
+	if (ret < 0)
+		return ret;
+	else if (pbc->mute_gpio_inverted)
+		ucontrol->value.integer.value[0] = !ret;
+	else
+		ucontrol->value.integer.value[0] = !!ret;
+
+	return 0;
+}
+
+static int pistachio_card_set_mute(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int val;
+
+	if (pbc->mute_gpio_inverted)
+		val = !ucontrol->value.integer.value[0];
+	else
+		val = ucontrol->value.integer.value[0];
+
+	gpio_set_value_cansleep(pbc->mute_gpio, val);
+
+	return 0;
+}
+
+static int pistachio_card_info_sample_rates(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 192000;
+
+	return 0;
+}
+
+static int pistachio_card_set_sample_rates_mclk(struct pistachio_card *pbc,
+		struct pistachio_mclk *mclk, unsigned int i2s_out_rate,
+		unsigned int i2s_in_rate)
+{
+	struct pistachio_i2s_mclk *mclk_a, *mclk_b;
+	unsigned int rate_a, rate_b;
+	int ret = 0;
+
+	mclk_a = NULL;
+	mclk_b = NULL;
+	rate_a = i2s_out_rate;
+	rate_b = i2s_in_rate;
+
+	if (i2s_out_rate) {
+		if (pbc->i2s_out->i2s.mclk_a.mclk == mclk)
+			mclk_a = &pbc->i2s_out->i2s.mclk_a;
+		else if (pbc->i2s_out->i2s.mclk_b.mclk == mclk)
+			mclk_a = &pbc->i2s_out->i2s.mclk_b;
+	}
+	if (i2s_in_rate) {
+		if (pbc->i2s_in->i2s.mclk_a.mclk == mclk)
+			mclk_b = &pbc->i2s_in->i2s.mclk_a;
+		else if (pbc->i2s_in->i2s.mclk_b.mclk == mclk)
+			mclk_b = &pbc->i2s_in->i2s.mclk_b;
+	}
+	if (!mclk_a) {
+		mclk_a = mclk_b;
+		rate_a = rate_b;
+		mclk_b = NULL;
+	}
+
+	if (mclk_a) {
+		ret = pistachio_card_update_mclk(pbc, mclk_a, mclk_b, rate_a,
+						rate_b);
+	}
+
+	return ret;
+}
+
+static int pistachio_card_set_sample_rates(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+	int ret;
+	unsigned int pll_rate, i2s_out_rate = 0, i2s_in_rate = 0;
+
+	if (pbc->i2s_out)
+		i2s_out_rate = ucontrol->value.integer.value[0];
+	if (pbc->i2s_in && pbc->i2s_in->i2s.mclk_a.mclk)
+		i2s_in_rate = ucontrol->value.integer.value[1];
+
+	if (!i2s_out_rate && !i2s_in_rate)
+		return 0;
+
+	pll_rate = 0;
+
+	if (i2s_out_rate) {
+		ret = pistachio_card_get_pll_rate(i2s_out_rate);
+		if (ret < 0)
+			return ret;
+		pll_rate = ret;
+	}
+
+	if (i2s_in_rate) {
+		ret = pistachio_card_get_pll_rate(i2s_in_rate);
+		if (ret < 0)
+			return ret;
+		if (pll_rate && (ret != pll_rate))
+			return -EINVAL;
+		pll_rate = ret;
+	}
+
+	mutex_lock(&pbc->rate_mutex);
+
+	if (pbc->audio_pll_rate != pll_rate) {
+		ret = pistachio_card_set_pll_rate(pbc, pll_rate);
+		if (ret) {
+			mutex_unlock(&pbc->rate_mutex);
+			return ret;
+		}
+	}
+
+	ret = pistachio_card_set_sample_rates_mclk(pbc, &pbc->i2s_mclk,
+						i2s_out_rate, i2s_in_rate);
+	if (ret) {
+		mutex_unlock(&pbc->rate_mutex);
+		return ret;
+	}
+
+	ret = pistachio_card_set_sample_rates_mclk(pbc, &pbc->dac_mclk,
+						i2s_out_rate, i2s_in_rate);
+
+	mutex_unlock(&pbc->rate_mutex);
+
+	return ret;
+}
+
+static struct snd_kcontrol_new pistachio_controls[] = {
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Event Time",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_event_time
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Measurement Source A",
+		.info = pistachio_card_info_source,
+		.get = pistachio_card_get_source_a,
+		.put = pistachio_card_set_source_a
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Measurement Source B",
+		.info = pistachio_card_info_source,
+		.get = pistachio_card_get_source_b,
+		.put = pistachio_card_set_source_b
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Rate A",
+		.info = pistachio_card_info_sample_rate,
+		.get = pistachio_card_get_sample_rate_a,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Rate B",
+		.info = pistachio_card_info_sample_rate,
+		.get = pistachio_card_get_sample_rate_b,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Period A",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_sample_period_a,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Sample Period B",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_sample_period_b,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_READ |
+			SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Phase Difference",
+		.info = pistachio_card_info_timespec,
+		.get = pistachio_card_get_phase_difference,
+	},
+	{
+		.access = SNDRV_CTL_ELEM_ACCESS_WRITE,
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "I2S Rates",
+		.info = pistachio_card_info_sample_rates,
+		.put = pistachio_card_set_sample_rates
+	},
+};
+
+#ifdef DEBUG
+
+static void pistachio_card_info_mclk(struct pistachio_card *pbc,
+					struct pistachio_i2s_mclk *mclk)
+{
+	struct device *dev = pbc->card.dev;
+	int i;
+
+	dev_dbg(dev, "        Min Freq: %u\n", mclk->mclk->min_rate);
+	dev_dbg(dev, "        Max Freq: %u\n", mclk->mclk->max_rate);
+	dev_dbg(dev, "        FS Rates:\n");
+
+	for (i = 0; i < mclk->num_fs_rates; i++)
+		dev_dbg(dev, "            %u\n", mclk->fs_rates[i]);
+}
+
+static void pistachio_card_info_mclks(struct pistachio_card *pbc,
+					struct pistachio_i2s *i2s)
+{
+	struct pistachio_i2s_mclk *i2s_mclk;
+	struct pistachio_i2s_mclk *dac_mclk;
+	struct device *dev = pbc->card.dev;
+
+	if (i2s->mclk_a.mclk == &pbc->i2s_mclk)
+		i2s_mclk = &i2s->mclk_a;
+	else if (pbc->i2s_in->i2s.mclk_b.mclk == &pbc->i2s_mclk)
+		i2s_mclk = &i2s->mclk_b;
+	else
+		i2s_mclk = NULL;
+
+	if (i2s_mclk) {
+		dev_dbg(dev, "    I2S MCLK\n");
+		pistachio_card_info_mclk(pbc, i2s_mclk);
+	} else {
+		dev_dbg(dev, "    I2S MCLK NOT USED\n");
+	}
+
+	dev_dbg(dev, "\n");
+
+	if (i2s->mclk_a.mclk == &pbc->dac_mclk)
+		dac_mclk = &i2s->mclk_a;
+	else if (i2s->mclk_b.mclk == &pbc->dac_mclk)
+		dac_mclk = &i2s->mclk_b;
+	else
+		dac_mclk = NULL;
+
+	if (dac_mclk) {
+		dev_dbg(dev, "    DAC MCLK\n");
+		pistachio_card_info_mclk(pbc, dac_mclk);
+	} else {
+		dev_dbg(dev, "    DAC MCLK NOT USED\n");
+	}
+}
+
+static void pistachio_card_info_i2s_out(struct pistachio_card *pbc,
+					struct snd_soc_dai_link *link)
+{
+	int i, j;
+	struct snd_soc_dai_link_component *components;
+	struct snd_soc_codec_conf *confs;
+	struct device *dev = pbc->card.dev;
+	char *text;
+
+	components = pbc->i2s_out->i2s.components;
+	confs = pbc->card.codec_conf;
+
+	dev_dbg(dev, "I2S OUT\n");
+	dev_dbg(dev, "\n");
+	if (pbc->i2s_in && (pbc->i2s_in->frame_master ==
+			PISTACHIO_CLOCK_MASTER_LOOPBACK))
+		text = "(Dual Frame + Bit Clock Master)";
+	else
+		text = "(Frame + Bit Clock Master)";
+	dev_dbg(dev, "    CPU DAI\n");
+	dev_dbg(dev, "        i2s-out (%s) %s\n",
+		link->cpu_of_node->name, text);
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CODECS\n");
+
+	for (i = 0; i < pbc->i2s_out->i2s.num_codecs; i++) {
+		for (j = 0; j < pbc->card.num_configs; j++)
+			if (confs[j].of_node == components[i].of_node)
+				break;
+
+		dev_dbg(dev, "        %s (%s) (%s)\n", confs[j].name_prefix,
+			confs[j].of_node->name,
+			components[i].dai_name);
+	}
+	dev_dbg(dev, "\n");
+
+	pistachio_card_info_mclks(pbc, &pbc->i2s_out->i2s);
+
+	dev_dbg(dev, "\n");
+
+	if ((link->dai_fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		text = "I2S";
+	else
+		text = "Left Justified";
+	dev_dbg(dev, "    Format: %s\n", text);
+
+	if ((link->dai_fmt & SND_SOC_DAIFMT_CLOCK_MASK) == SND_SOC_DAIFMT_CONT)
+		text = "Yes";
+	else
+		text = "No";
+	dev_dbg(dev, "    Continuous Clock: %s\n", text);
+
+	dev_dbg(dev, "\n");
+}
+
+static void pistachio_card_info_i2s_in(struct pistachio_card *pbc,
+					struct snd_soc_dai_link *link)
+{
+	int i, j;
+	struct snd_soc_dai_link_component *components;
+	struct snd_soc_codec_conf *confs;
+	char *text;
+	struct device *dev = pbc->card.dev;
+
+	components = pbc->i2s_in->i2s.components;
+	confs = pbc->card.codec_conf;
+
+	dev_dbg(dev, "I2S IN\n");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CPU DAI\n");
+	dev_dbg(dev, "        i2s-in (%s)\n",
+		link->cpu_of_node->name);
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "    CODECS\n");
+
+	for (i = 0; i < pbc->i2s_out->i2s.num_codecs; i++) {
+		for (j = 0; j < pbc->card.num_configs; j++)
+			if (confs[j].of_node == components[i].of_node)
+				break;
+
+		if (i == pbc->i2s_in->frame_master)
+			if (i == pbc->i2s_in->bitclock_master)
+				text = "(Frame + Bit Clock Master)";
+			else
+				text = "(Frame Master)";
+		else
+			if (i == pbc->i2s_in->bitclock_master)
+				text = "(Bitclock Master)";
+			else
+				text = "";
+
+		dev_dbg(dev, "        %s (%s) (%s) %s\n", confs[j].name_prefix,
+			confs[j].of_node->name,
+			components[i].dai_name, text);
+	}
+	dev_dbg(dev, "\n");
+
+	pistachio_card_info_mclks(pbc, &pbc->i2s_in->i2s);
+
+	dev_dbg(dev, "\n");
+
+	if ((pbc->i2s_in->fmt & SND_SOC_DAIFMT_FORMAT_MASK) ==
+			SND_SOC_DAIFMT_I2S)
+		text = "I2S";
+	else
+		text = "Left Justified";
+	dev_dbg(dev, "    Format: %s\n", text);
+
+	if ((pbc->i2s_in->fmt & SND_SOC_DAIFMT_CLOCK_MASK) ==
+			SND_SOC_DAIFMT_CONT)
+		text = "Yes";
+	else
+		text = "No";
+	dev_dbg(dev, "    Continuous Clock: %s\n", text);
+
+	dev_dbg(dev, "\n");
+}
+
+static void pistachio_card_info(struct pistachio_card *pbc)
+{
+	struct device *dev = pbc->card.dev;
+	struct snd_soc_codec_conf *conf;
+	struct snd_soc_dai_link *link;
+	char *text;
+
+	link = pbc->card.dai_link;
+
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "####################################################\n");
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "Pistachio Audio Card\n");
+	dev_dbg(dev, "\n");
+
+	if (pbc->spdif_out) {
+		dev_dbg(dev, "SPDIF OUT\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        spdif-out (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->spdif_in) {
+		dev_dbg(dev, "SPDIF IN\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        spdif-in (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->parallel_out) {
+		dev_dbg(dev, "PARALLEL OUT\n");
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CPU DAI\n");
+		dev_dbg(dev, "        parallel-out (%s)\n",
+			link->cpu_of_node->name);
+		dev_dbg(dev, "\n");
+		dev_dbg(dev, "    CODECS\n");
+		conf = &pbc->card.codec_conf[pbc->card.num_configs - 1];
+		dev_dbg(dev, "        %s (%s) (%s)\n", conf->name_prefix,
+			conf->of_node->name,
+			pbc->parallel_out->internal_dac.dai_name);
+		dev_dbg(dev, "\n");
+		link++;
+	}
+	if (pbc->i2s_out) {
+		pistachio_card_info_i2s_out(pbc, link);
+		link++;
+	}
+
+	if (pbc->i2s_in)
+		pistachio_card_info_i2s_in(pbc, link);
+
+	if (gpio_is_valid(pbc->mute_gpio)) {
+		if (pbc->mute_gpio_inverted)
+			text = "(Active Low)";
+		else
+			text = "(Active High)";
+		dev_dbg(dev, "Mute: GPIO %u %s\n", pbc->mute_gpio, text);
+	}
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio)) {
+		if (pbc->hp_jack_gpio.invert)
+			text = "(Active Low)";
+		else
+			text = "(Active High)";
+		dev_dbg(dev, "Headphone-Detect: GPIO %u %s\n",
+				pbc->hp_jack_gpio.gpio, text);
+	}
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "####################################################\n");
+	dev_dbg(dev, "\n");
+}
+
+#endif
+
+static int pistachio_card_probe(struct platform_device *pdev)
+{
+	struct pistachio_card *pbc;
+	struct device_node *np = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	int ret;
+	unsigned long gpio_flags;
+	struct snd_kcontrol_new *control;
+
+	if (!np || !of_device_is_available(np))
+		return -EINVAL;
+
+	pbc = devm_kzalloc(dev, sizeof(*pbc), GFP_KERNEL);
+	if (!pbc)
+		return -ENOMEM;
+
+	pbc->card.owner = THIS_MODULE;
+	pbc->card.dev = dev;
+	pbc->card.name = "pistachio-card";
+
+	snd_soc_card_set_drvdata(&pbc->card, pbc);
+
+	mutex_init(&pbc->rate_mutex);
+
+	pbc->hp_jack_gpio.gpio = -ENOENT;
+	pbc->mute_gpio = -ENOENT;
+
+	ret = pistachio_card_parse_of(np, pbc);
+	if (ret)
+		goto err;
+
+	ret = pistachio_card_init_clk(dev, "audio_pll", &pbc->audio_pll);
+	if (ret)
+		goto err;
+
+	ret = pistachio_card_init_clk(dev, "i2s_mclk", &pbc->i2s_mclk.mclk);
+	if (ret)
+		goto err_clk_audio_pll;
+
+	ret = pistachio_card_init_clk(dev, "dac_clk", &pbc->dac_mclk.mclk);
+	if (ret)
+		goto err_clk_i2s;
+
+	ret = pistachio_card_init_rates(pbc);
+	if (ret)
+		goto err_clk_dac;
+
+	pbc->i2s_clk_notifier.notifier_call = pistachio_card_i2s_clk_cb;
+	ret = clk_notifier_register(pbc->i2s_mclk.mclk,
+					&pbc->i2s_clk_notifier);
+	if (ret)
+		goto err_clk_dac;
+
+	ret = devm_snd_soc_register_card(dev, &pbc->card);
+	if (ret)
+		goto err_notifier;
+
+	ret = snd_soc_add_card_controls(&pbc->card, pistachio_controls,
+					ARRAY_SIZE(pistachio_controls));
+	if (ret)
+		goto err_notifier;
+
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio)) {
+		pbc->hp_jack_pin.pin = "Headphones";
+		pbc->hp_jack_pin.mask = SND_JACK_HEADPHONE;
+		pbc->hp_jack_gpio.name = "Headphone detection";
+		pbc->hp_jack_gpio.report = SND_JACK_HEADPHONE;
+		pbc->hp_jack_gpio.debounce_time = 150;
+		ret = snd_soc_card_jack_new(&pbc->card, "Headphones",
+			SND_JACK_HEADPHONE, &pbc->hp_jack, &pbc->hp_jack_pin,
+			1);
+		if (ret)
+			goto err_notifier;
+		ret = snd_soc_jack_add_gpios(&pbc->hp_jack, 1,
+				&pbc->hp_jack_gpio);
+		if (ret)
+			goto err_notifier;
+	}
+
+	if (gpio_is_valid(pbc->mute_gpio)) {
+		if (pbc->mute_gpio_inverted)
+			gpio_flags = GPIOF_OUT_INIT_HIGH;
+		else
+			gpio_flags = GPIOF_OUT_INIT_LOW;
+		ret = gpio_request_one(pbc->mute_gpio, gpio_flags, "Mute");
+		if (ret)
+			goto err_jack;
+		control = devm_kzalloc(dev, sizeof(*control), GFP_KERNEL);
+		if (!control) {
+			ret = -ENOMEM;
+			goto err_mute;
+		}
+		control->access = SNDRV_CTL_ELEM_ACCESS_READWRITE;
+		control->iface = SNDRV_CTL_ELEM_IFACE_CARD;
+		control->name = "Mute Switch";
+		control->info = snd_ctl_boolean_mono_info;
+		control->get = pistachio_card_get_mute;
+		control->put = pistachio_card_set_mute;
+		ret = snd_soc_add_card_controls(&pbc->card, control, 1);
+		if (ret)
+			goto err_mute;
+	}
+
+#ifdef	DEBUG
+	pistachio_card_info(pbc);
+#endif
+
+	return 0;
+
+err_mute:
+	if (gpio_is_valid(pbc->mute_gpio))
+		gpio_free(pbc->mute_gpio);
+err_jack:
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio))
+		snd_soc_jack_free_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+err_notifier:
+	clk_notifier_unregister(pbc->i2s_mclk.mclk, &pbc->i2s_clk_notifier);
+err_clk_dac:
+	clk_disable_unprepare(pbc->dac_mclk.mclk);
+err_clk_i2s:
+	clk_disable_unprepare(pbc->i2s_mclk.mclk);
+err_clk_audio_pll:
+	clk_disable_unprepare(pbc->audio_pll);
+err:
+	pistachio_card_unref(pbc);
+
+	return ret;
+}
+
+static int pistachio_card_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct pistachio_card *pbc = snd_soc_card_get_drvdata(card);
+
+	pistachio_evt_abort_measurements(pbc->event_timer);
+	if (gpio_is_valid(pbc->mute_gpio))
+		gpio_free(pbc->mute_gpio);
+	if (gpio_is_valid(pbc->hp_jack_gpio.gpio))
+		snd_soc_jack_free_gpios(&pbc->hp_jack, 1, &pbc->hp_jack_gpio);
+	clk_notifier_unregister(pbc->i2s_mclk.mclk, &pbc->i2s_clk_notifier);
+	clk_disable_unprepare(pbc->dac_mclk.mclk);
+	clk_disable_unprepare(pbc->i2s_mclk.mclk);
+	clk_disable_unprepare(pbc->audio_pll);
+	pistachio_card_unref(pbc);
+
+	return 0;
+}
+
+static const struct of_device_id pistachio_card_of_match[] = {
+	{ .compatible = "img,pistachio-audio" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pistachio_card_of_match);
+
+static struct platform_driver pistachio_card = {
+	.driver = {
+		.name = "pistachio-card",
+		.of_match_table = pistachio_card_of_match,
+	},
+	.probe = pistachio_card_probe,
+	.remove = pistachio_card_remove,
+};
+module_platform_driver(pistachio_card);
+
+MODULE_DESCRIPTION("Pistachio audio card driver");
+MODULE_AUTHOR("Damien Horsley <Damien.Horsley@imgtec.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/soc-generic-dmaengine-pcm.c b/sound/soc/soc-generic-dmaengine-pcm.c
index 6cef397..589b860 100644
--- a/sound/soc/soc-generic-dmaengine-pcm.c
+++ b/sound/soc/soc-generic-dmaengine-pcm.c
@@ -35,6 +35,7 @@ struct dmaengine_pcm {
 	const struct snd_dmaengine_pcm_config *config;
 	struct snd_soc_platform platform;
 	unsigned int flags;
+	bool dma_pre_started;
 };
 
 static struct dmaengine_pcm *soc_platform_to_pcm(struct snd_soc_platform *p)
@@ -329,14 +330,90 @@ static snd_pcm_uframes_t dmaengine_pcm_pointer(
 		return snd_dmaengine_pcm_pointer(substream);
 }
 
+int dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		if(!pcm->dma_pre_started) {
+			ret = dmaengine_pcm_prepare_and_submit(substream);
+			if (ret)
+				return ret;
+			dma_async_issue_pending(dma_chan);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->runtime->hw.info & SNDRV_PCM_INFO_RESUME)
+			dmaengine_resume(dma_chan);
+		else
+			return -ENOSYS;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->runtime->hw.info & SNDRV_PCM_INFO_PAUSE)
+			dmaengine_pause(dma_chan);
+		else
+			dmaengine_terminate_all(dma_chan);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		dmaengine_terminate_all(dma_chan);
+		pcm->dma_pre_started = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dmaengine_start_at(struct snd_pcm_substream *substream,
+	int audio_clock_type, const struct timespec *ts)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret;
+
+	if(pcm->flags & SND_DMAENGINE_PCM_FLAG_EARLY_START) {
+		ret = dmaengine_pcm_prepare_and_submit(substream);
+		if (ret)
+			return ret;
+		dma_async_issue_pending(dma_chan);
+		pcm->dma_pre_started = true;
+	}
+
+	return 0;
+}
+
+static int dmaengine_start_at_abort(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct dmaengine_pcm *pcm = soc_platform_to_pcm(rtd->platform);
+	struct dma_chan *dma_chan = snd_dmaengine_pcm_get_chan(substream);
+
+	if(pcm->dma_pre_started) {
+		dmaengine_terminate_all(dma_chan);
+		pcm->dma_pre_started = false;
+	}
+
+	return 0;
+}
+
 static const struct snd_pcm_ops dmaengine_pcm_ops = {
 	.open		= dmaengine_pcm_open,
 	.close		= snd_dmaengine_pcm_close,
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= dmaengine_pcm_hw_params,
 	.hw_free	= snd_pcm_lib_free_pages,
-	.trigger	= snd_dmaengine_pcm_trigger,
+	.trigger	= dmaengine_pcm_trigger,
 	.pointer	= dmaengine_pcm_pointer,
+	.start_at	= dmaengine_start_at,
+	.start_at_abort = dmaengine_start_at_abort
 };
 
 static const struct snd_soc_platform_driver dmaengine_pcm_platform = {
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index d56a16a..4ecc424 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -1084,6 +1084,91 @@ static int soc_pcm_bespoke_trigger(struct snd_pcm_substream *substream,
 	}
 	return 0;
 }
+
+static int soc_pcm_start_at(struct snd_pcm_substream *substream,
+	int audio_clock_type, const struct timespec *start_time)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec_dai = rtd->codec_dais[i];
+		if (codec_dai->driver->ops &&
+		    codec_dai->driver->ops->start_at) {
+			ret = codec_dai->driver->ops->start_at(substream,
+				codec_dai, audio_clock_type, start_time);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (platform->driver->ops && platform->driver->ops->start_at) {
+		ret = platform->driver->ops->start_at(substream,
+					audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->start_at) {
+		ret = cpu_dai->driver->ops->start_at(substream,
+			cpu_dai, audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->start_at) {
+		ret = rtd->dai_link->ops->start_at(substream,
+			audio_clock_type, start_time);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int soc_pcm_start_at_abort(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai;
+	int i, ret;
+
+	for (i = 0; i < rtd->num_codecs; i++) {
+		codec_dai = rtd->codec_dais[i];
+		if (codec_dai->driver->ops &&
+		    codec_dai->driver->ops->start_at_abort) {
+			ret = codec_dai->driver->ops->start_at_abort(
+				substream, codec_dai);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	if (platform->driver->ops && platform->driver->ops->start_at_abort) {
+		ret = platform->driver->ops->start_at_abort(substream);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (cpu_dai->driver->ops && cpu_dai->driver->ops->start_at_abort) {
+		ret = cpu_dai->driver->ops->start_at_abort(substream, cpu_dai);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (rtd->dai_link->ops && rtd->dai_link->ops->start_at_abort) {
+		ret = rtd->dai_link->ops->start_at_abort(substream);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 /*
  * soc level wrapper for pointer callback
  * If cpu_dai, codec_dai, platform driver has the delay callback, than
@@ -2729,6 +2814,8 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 		rtd->ops.close		= dpcm_fe_dai_close;
 		rtd->ops.pointer	= soc_pcm_pointer;
 		rtd->ops.ioctl		= soc_pcm_ioctl;
+		rtd->ops.start_at	= soc_pcm_start_at;
+		rtd->ops.start_at_abort	= soc_pcm_start_at_abort;
 	} else {
 		rtd->ops.open		= soc_pcm_open;
 		rtd->ops.hw_params	= soc_pcm_hw_params;
@@ -2738,6 +2825,8 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 		rtd->ops.close		= soc_pcm_close;
 		rtd->ops.pointer	= soc_pcm_pointer;
 		rtd->ops.ioctl		= soc_pcm_ioctl;
+		rtd->ops.start_at	= soc_pcm_start_at;
+		rtd->ops.start_at_abort	= soc_pcm_start_at_abort;
 	}
 
 	if (platform->driver->ops) {
-- 
2.7.4

